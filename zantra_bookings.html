<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zantra Bookings Console</title>
    <script>
      window.tailwind = window.tailwind || {};
      window.tailwind.config = {
        theme: {
          extend: {
            colors: {
              brand: {
                primary: "#4b0082",
                accent: "#a855f7",
              },
            },
            fontFamily: {
              sans: [
                "Inter",
                "Segoe UI",
                "system-ui",
                "-apple-system",
                "BlinkMacSystemFont",
                "sans-serif",
              ],
            },
          },
        },
      };
    </script>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js"></script>
    <script>
      const supabaseUrl = "https://imqnxsrdwkgvjojsowj.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdX...";

      const supabaseClient =
        typeof window !== "undefined" && window.supabase
          ? window.supabase.createClient(supabaseUrl, supabaseKey)
          : null;
      if (supabaseClient) {
        window.supabaseClient = supabaseClient;
      } else {
        console.error("Supabase client failed to initialize.");
      }
    </script>

    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont,
          sans-serif;
        --slate-100: #f8fafc;
        --slate-950: #020617;
        --slate-900: #0f172a;
        --slate-800: #1e293b;
        --slate-700: #334155;
        --slate-600: #475569;
        --slate-500: #64748b;
        --slate-400: #94a3b8;
        --slate-300: #cbd5f5;
        --brand-primary: #4c1d95;
        --brand-primary-soft: #5b21b6;
        --brand-primary-rgb: 76, 29, 149;
        --brand-accent: #8b5cf6;
        --brand-accent-rgb: 139, 92, 246;
        --emerald-400: #34d399;
        --amber-400: #fbbf24;
        --sky-400: #38bdf8;
        --rose-400: #fb7185;
        --white: #ffffff;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background-color: var(--slate-950);
        color: var(--slate-100);
        min-height: 100vh;
        font-family: inherit;
        line-height: 1.6;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 0;
      }
      a,
      button,
      input,
      select,
      textarea {
        font: inherit;
        color: inherit;
      }
      button {
        cursor: pointer;
        border: none;
        background: none;
      }
      input,
      select,
      textarea {
        background-color: var(--slate-900);
        border: 1px solid var(--slate-700);
        color: inherit;
        border-radius: 0.75rem;
        padding: 0.5rem 0.75rem;
      }
      button:focus,
      button:focus-visible,
      input:focus,
      input:focus-visible,
      select:focus,
      select:focus-visible,
      textarea:focus,
      textarea:focus-visible {
        outline: 2px solid var(--brand-accent);
        outline-offset: 2px;
      }
      .app-shell {
        max-width: 1120px;
        margin: 0 auto;
        padding: 2rem 1.25rem;
        display: grid;
        gap: 1.5rem;
      }
      .card {
        background: rgba(15, 23, 42, 0.75);
        border: 1px solid rgba(148, 163, 184, 0.15);
        border-radius: 1rem;
        padding: 1.5rem;
        box-shadow: 0 25px 60px rgba(2, 6, 23, 0.45);
        backdrop-filter: blur(12px);
      }
      .grid {
        display: grid;
        gap: 1.25rem;
      }
      .grid-2 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .grid-3 {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
      .gap-sm {
        gap: 0.75rem;
      }
      .gap-md {
        gap: 1rem;
      }
      .gap-lg {
        gap: 1.5rem;
      }
      .mt-1 {
        margin-top: 0.5rem;
      }
      .mt-2 {
        margin-top: 1rem;
      }
      .text-muted {
        color: var(--slate-400);
      }
      .text-subtle {
        color: var(--slate-500);
      }
      .text-small {
        font-size: 0.9rem;
      }
      .text-xs {
        font-size: 0.75rem;
      }
      .text-center {
        text-align: center;
      }
      .flex {
        display: flex;
      }
      .flex-wrap {
        flex-wrap: wrap;
      }
      .items-center {
        align-items: center;
      }
      .items-start {
        align-items: flex-start;
      }
      .justify-between {
        justify-content: space-between;
      }
      .justify-end {
        justify-content: flex-end;
      }
      .list-plain {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 0.75rem;
      }
      .btn {
        border-radius: 0.75rem;
        padding: 0.5rem 1rem;
        font-weight: 600;
        transition: background 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease;
        border: 1px solid rgba(var(--brand-primary-rgb), 0.45);
        background: rgba(var(--brand-primary-rgb), 0.16);
        color: var(--slate-100);
      }
      .btn:hover {
        transform: translateY(-1px);
        background: rgba(var(--brand-primary-rgb), 0.25);
        box-shadow: 0 10px 24px rgba(var(--brand-primary-rgb), 0.35);
      }
      .btn-primary {
        background: linear-gradient(135deg, rgba(var(--brand-primary-rgb), 0.95), rgba(var(--brand-primary-rgb), 0.7));
        color: var(--white);
        border: none;
        box-shadow: 0 14px 32px rgba(var(--brand-primary-rgb), 0.45);
      }
      .btn-primary:hover {
        background: linear-gradient(135deg, rgba(var(--brand-primary-rgb), 1), rgba(var(--brand-primary-rgb), 0.85));
        box-shadow: 0 18px 36px rgba(var(--brand-primary-rgb), 0.55);
      }
      .btn-ghost {
        padding: 0.35rem 0.6rem;
        border-radius: 0.6rem;
        border: 1px solid transparent;
        background: transparent;
      }
      .btn-ghost:hover {
        border-color: rgba(var(--brand-primary-rgb), 0.35);
        background: rgba(var(--brand-primary-rgb), 0.12);
      }
      .btn-sm {
        padding: 0.35rem 0.6rem;
        font-size: 0.8rem;
      }
      .app-header {
        background: linear-gradient(135deg, rgba(var(--brand-primary-rgb), 0.92), rgba(2, 6, 23, 0.92));
        border: 1px solid rgba(var(--brand-primary-rgb), 0.45);
      }
      .header-brand {
        display: flex;
        align-items: center;
        gap: 1rem;
      }
      .brand-logo {
        height: 48px;
        width: auto;
        flex-shrink: 0;
        border-radius: 0.5rem;
        display: block;
      }
      .brand-preview {
        display: grid;
        gap: 0.35rem;
        padding: 1rem;
        border-radius: 0.75rem;
        border: 1px solid rgba(var(--brand-accent-rgb), 0.4);
        background: rgba(15, 23, 42, 0.6);
      }
      .brand-preview h4 {
        color: var(--brand-accent);
      }
      .brand-preview-logo {
        height: 40px;
        width: auto;
        margin-bottom: 0.5rem;
        justify-self: start;
      }
      .form-field {
        display: grid;
        gap: 0.35rem;
      }
      .form-label {
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--slate-300);
      }
      .header-actions {
        display: flex;
        gap: 0.75rem;
      }
      .sync-indicator {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.35rem 0.75rem;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.16);
        color: var(--slate-300);
        font-size: 0.8rem;
        line-height: 1;
        border: 1px solid rgba(148, 163, 184, 0.25);
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      }
      .sync-indicator::before {
        content: "";
        width: 0.55rem;
        height: 0.55rem;
        border-radius: 999px;
        background: rgba(52, 211, 153, 0.9);
        box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.25);
      }
      .sync-indicator[data-state="synced"] {
        background: rgba(52, 211, 153, 0.12);
        color: #6ee7b7;
        border-color: rgba(52, 211, 153, 0.4);
      }
      .sync-indicator[data-state="synced"]::before {
        background: rgba(52, 211, 153, 0.95);
        box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.25);
      }
      .sync-indicator[data-state="syncing"] {
        background: rgba(var(--brand-accent-rgb), 0.12);
        color: var(--brand-accent);
        border-color: rgba(var(--brand-accent-rgb), 0.45);
      }
      .sync-indicator[data-state="syncing"]::before {
        background: var(--brand-accent);
        box-shadow: 0 0 0 2px rgba(var(--brand-accent-rgb), 0.2);
        animation: sync-pulse 1.4s infinite ease-in-out;
      }
      .sync-indicator[data-state="error"] {
        background: rgba(248, 113, 113, 0.12);
        color: #fca5a5;
        border-color: rgba(248, 113, 113, 0.35);
      }
      .sync-indicator[data-state="error"]::before {
        background: #f87171;
        box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.25);
      }
      .sync-indicator[data-state="idle"]::before {
        background: rgba(148, 163, 184, 0.75);
        box-shadow: 0 0 0 2px rgba(148, 163, 184, 0.2);
      }
      @keyframes sync-pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.2);
          opacity: 0.5;
        }
      }
      nav ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        border: 1px solid rgba(var(--brand-primary-rgb), 0.35);
        border-radius: 0.75rem;
        overflow-x: auto;
        overflow-y: hidden;
        background: rgba(15, 23, 42, 0.7);
        box-shadow: inset 0 0 0 1px rgba(var(--brand-primary-rgb), 0.08);
      }
      nav ul::-webkit-scrollbar {
        height: 6px;
      }
      nav ul::-webkit-scrollbar-thumb {
        background: rgba(var(--brand-primary-rgb), 0.45);
        border-radius: 999px;
      }
      nav li {
        flex: 1 1 0;
      }
      nav button {
        width: 100%;
        padding: 0.75rem 1rem;
        text-align: center;
        font-weight: 600;
        background: rgba(var(--brand-primary-rgb), 0.12);
        transition: background 0.2s ease, box-shadow 0.2s ease;
        border-right: 1px solid rgba(var(--brand-primary-rgb), 0.2);
        min-width: 160px;
      }
      nav li:last-child button {
        border-right: none;
      }
      nav button:hover,
      nav button:focus-visible {
        background: rgba(var(--brand-primary-rgb), 0.2);
      }
      nav button.active {
        background: linear-gradient(135deg, rgba(var(--brand-primary-rgb), 0.95), rgba(var(--brand-primary-rgb), 0.7));
        color: var(--white);
        box-shadow: 0 12px 28px rgba(var(--brand-primary-rgb), 0.45);
      }
      .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, minmax(0, 1fr));
        gap: 0.5rem;
        min-width: 520px;
      }
      .calendar-wrapper {
        margin-top: 0.75rem;
        display: grid;
        gap: 0.5rem;
        overflow-x: auto;
        padding-bottom: 0.5rem;
        -webkit-overflow-scrolling: touch;
      }
      .calendar-wrapper::-webkit-scrollbar {
        height: 8px;
      }
      .calendar-wrapper::-webkit-scrollbar-thumb {
        background: rgba(var(--brand-primary-rgb), 0.45);
        border-radius: 999px;
      }
      .calendar-weekdays {
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .calendar-cell {
        position: relative;
        min-height: 96px;
        border-radius: 0.75rem;
        border: 1px solid rgba(148, 163, 184, 0.15);
        background: rgba(2, 6, 23, 0.85);
        padding: 0.75rem;
        text-align: left;
        display: grid;
        gap: 0.35rem;
        align-content: start;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .calendar-cell:hover {
        border-color: rgba(var(--brand-primary-rgb), 0.35);
        box-shadow: inset 0 0 0 1px rgba(var(--brand-primary-rgb), 0.2);
      }
      .calendar-cell.active {
        border-color: rgba(var(--brand-primary-rgb), 0.65);
        background: rgba(var(--brand-primary-rgb), 0.22);
        box-shadow: inset 0 0 0 1px rgba(var(--brand-primary-rgb), 0.35);
      }
      .badge {
        padding: 0.2rem 0.5rem;
        border-radius: 999px;
        font-size: 0.7rem;
        text-transform: uppercase;
        font-weight: 700;
        letter-spacing: 0.04em;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
      }
      .badge-confirmed {
        background: rgba(16, 185, 129, 0.12);
        color: var(--emerald-400);
      }
      .badge-pending {
        background: rgba(251, 191, 36, 0.12);
        color: var(--amber-400);
      }
      .badge-default {
        background: rgba(148, 163, 184, 0.12);
        color: var(--slate-300);
      }
      .table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }
      .table thead {
        color: var(--slate-400);
        font-weight: 600;
      }
      .table th,
      .table td {
        padding: 0.6rem 0.5rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.15);
        vertical-align: top;
      }
      .table-actions {
        display: flex;
        gap: 0.5rem;
        justify-content: flex-end;
      }
      .empty {
        color: var(--slate-500);
        font-size: 0.9rem;
      }
      .toast-region {
        position: fixed;
        top: 1.25rem;
        right: 1.25rem;
        display: grid;
        gap: 0.75rem;
        z-index: 1000;
        pointer-events: none;
      }
      .toast {
        border-radius: 0.9rem;
        padding: 0.85rem 1rem;
        box-shadow: 0 22px 48px rgba(2, 6, 23, 0.6);
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.2s ease, transform 0.2s ease;
        pointer-events: auto;
        border: 1px solid transparent;
        border-left: 4px solid transparent;
        background: rgba(15, 23, 42, 0.96);
        display: grid;
        gap: 0.35rem;
        min-width: 240px;
        cursor: pointer;
      }
      .toast.visible {
        opacity: 1;
        transform: translateY(0);
      }
      .toast[data-tone="success"] {
        border-color: rgba(34, 197, 94, 0.35);
        border-left-color: rgba(34, 197, 94, 0.85);
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.16), rgba(15, 23, 42, 0.96));
      }
      .toast[data-tone="error"] {
        border-color: rgba(var(--rose-400), 0.4);
        border-left-color: var(--rose-400);
        background: linear-gradient(135deg, rgba(251, 113, 133, 0.2), rgba(15, 23, 42, 0.96));
      }
      .toast[data-tone="warning"] {
        border-color: rgba(var(--amber-400), 0.4);
        border-left-color: var(--amber-400);
        background: linear-gradient(135deg, rgba(251, 191, 36, 0.18), rgba(15, 23, 42, 0.96));
      }
      .toast[data-tone="info"] {
        border-color: rgba(var(--sky-400), 0.45);
        border-left-color: var(--sky-400);
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.2), rgba(15, 23, 42, 0.96));
      }
      .notification-item {
        display: flex;
        gap: 0.75rem;
        padding: 0.75rem;
        border-radius: 0.75rem;
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(148, 163, 184, 0.18);
        align-items: flex-start;
      }
      .notification-item[data-tone="info"] {
        border-left: 4px solid var(--brand-accent);
      }
      .notification-item[data-tone="warning"] {
        border-left: 4px solid var(--amber-400);
      }
      .notification-dot {
        margin-top: 0.2rem;
        width: 0.6rem;
        height: 0.6rem;
        border-radius: 999px;
        flex-shrink: 0;
      }
      .notification-dot.info {
        background-color: var(--brand-accent);
      }
      .notification-dot.warning {
        background-color: var(--amber-400);
      }
      .visually-hidden {
        position: absolute !important;
        height: 1px;
        width: 1px;
        overflow: hidden;
        clip: rect(1px, 1px, 1px, 1px);
        white-space: nowrap;
      }
      .hidden {
        display: none !important;
      }
      .text-error {
        color: #f87171;
      }
      .auth-container {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1.25rem;
        background: rgba(2, 6, 23, 0.85);
        backdrop-filter: blur(6px);
        z-index: 950;
      }
      .auth-card {
        width: min(100%, 420px);
      }
      .auth-card h2 {
        font-size: 1.45rem;
        margin-bottom: 0.35rem;
      }
      .auth-subtext {
        margin: 0;
      }
      @media (max-width: 900px) {
        .app-header .grid-2 {
          grid-template-columns: 1fr;
        }
        .header-brand {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.75rem;
        }
        .header-actions {
          width: 100%;
          justify-content: flex-start;
          gap: 0.5rem;
        }
        .header-actions .btn {
          flex: 1 1 auto;
        }
      }
      @media (max-width: 600px) {
        .grid-2,
        .grid-3 {
          grid-template-columns: 1fr !important;
        }
        nav ul {
          flex-direction: column;
          overflow-x: visible;
        }
        nav button {
          min-width: 100%;
          border-right: none;
        }
        nav li + li button {
          border-top: 1px solid rgba(var(--brand-primary-rgb), 0.2);
        }
        .toast-region {
          left: 50%;
          right: auto;
          transform: translateX(-50%);
          width: min(90vw, 22rem);
        }
        .toast {
          min-width: auto;
          width: 100%;
        }
        .app-shell {
          padding: 1.75rem 1rem 3.25rem;
        }
        .header-actions {
          justify-content: flex-start;
        }
      }
      @media (min-width: 900px) {
        .grid-2 {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
        .grid-3 {
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }
        .calendar-grid {
          min-width: 0;
        }
      }
    </style>
  </head>
  <body>
    <div
      id="toast-region"
      class="toast-region"
      aria-live="assertive"
      aria-atomic="true"
    ></div>
    <div
      id="auth-container"
      class="auth-container hidden"
      role="dialog"
      aria-modal="true"
      aria-labelledby="login-title"
    >
      <form
        id="login-form"
        class="card auth-card"
        autocomplete="off"
        novalidate
        aria-describedby="login-error"
      >
        <div class="grid gap-sm">
          <div>
            <h2 id="login-title">Sign in to Zantra Bookings</h2>
            <p class="text-muted text-small auth-subtext">
              Use your Zantra Supabase credentials to continue.
            </p>
          </div>
          <div class="form-field">
            <label class="form-label" for="login-email">Email</label>
            <input
              id="login-email"
              name="email"
              type="email"
              required
              autocomplete="email"
              inputmode="email"
            />
          </div>
          <div class="form-field">
            <label class="form-label" for="login-password">Password</label>
            <input
              id="login-password"
              name="password"
              type="password"
              required
              autocomplete="current-password"
            />
          </div>
          <p id="login-error" class="text-small text-error hidden" role="alert"></p>
          <button id="login-submit" class="btn btn-primary" type="submit">
            Sign in
          </button>
        </div>
      </form>
    </div>
    <div
      id="subscription-blocked"
      class="auth-container hidden"
      role="alertdialog"
      aria-modal="true"
      aria-labelledby="subscription-blocked-title"
      aria-describedby="subscription-blocked-message"
    >
      <div class="card auth-card text-center">
        <div class="grid gap-sm">
          <h2 id="subscription-blocked-title">Access restricted</h2>
          <p id="subscription-blocked-message" class="text-muted text-small">
            Your subscription is inactive. Please contact support.
          </p>
          <button id="subscription-blocked-return" class="btn btn-primary" type="button">
            Back to sign in
          </button>
        </div>
      </div>
    </div>
    <div class="app-shell hidden" id="app">
      <header class="card app-header">
        <div class="grid grid-2 gap-md items-start">
          <div class="header-brand">
            <img
              src="Zantra_Bookings_Logo.png"
              alt="Zantra Bookings Logo"
              class="brand-logo"
            />
            <div>
              <h1 id="branding-title">Zantra Bookings Suite</h1>
              <p class="text-muted mt-1">
                Manage bookings, invoices, and brand preferences from a single enterprise-ready
                console.
              </p>
            </div>
          </div>
          <div class="header-actions flex justify-end items-start flex-wrap">
            <span
              id="sync-status"
              class="sync-indicator"
              role="status"
              aria-live="polite"
              data-state="idle"
            >
              Offline
            </span>
            <button id="quick-add-booking" class="btn btn-primary" type="button">
              Quick Add Booking
            </button>
            <button id="quick-add-payment" class="btn" type="button">Record Payment</button>
            <button id="logout-button" class="btn btn-ghost btn-sm hidden" type="button">
              Log out
            </button>
          </div>
        </div>
      </header>

      <nav role="tablist" aria-label="Primary sections">
        <ul>
          <li>
            <button
              class="tab-button active"
              data-tab="dashboard"
              type="button"
              role="tab"
              aria-selected="true"
              aria-controls="tab-dashboard"
              tabindex="0"
            >
              Dashboard
            </button>
          </li>
          <li>
            <button
              class="tab-button"
              data-tab="bookings"
              type="button"
              role="tab"
              aria-selected="false"
              aria-controls="tab-bookings"
              tabindex="-1"
            >
              Calendar &amp; Bookings
            </button>
          </li>
          <li>
            <button
              class="tab-button"
              data-tab="payments"
              type="button"
              role="tab"
              aria-selected="false"
              aria-controls="tab-payments"
              tabindex="-1"
            >
              Payments &amp; Invoicing
            </button>
          </li>
          <li>
            <button
              class="tab-button"
              data-tab="reports"
              type="button"
              role="tab"
              aria-selected="false"
              aria-controls="tab-reports"
              tabindex="-1"
            >
              Reports &amp; Exports
            </button>
          </li>
          <li>
            <button
              class="tab-button"
              data-tab="settings"
              type="button"
              role="tab"
              aria-selected="false"
              aria-controls="tab-settings"
              tabindex="-1"
            >
              Settings &amp; Branding
            </button>
          </li>
        </ul>
      </nav>

      <main class="grid gap-lg">
        <section id="tab-dashboard" class="tab-panel">
          <div class="grid grid-3 gap-md">
            <div class="card">
              <h2>At a Glance</h2>
              <dl class="list-plain mt-2">
                <div class="flex justify-between">
                  <dt class="text-muted text-small">Upcoming bookings</dt>
                  <dd id="summary-upcoming">0</dd>
                </div>
                <div class="flex justify-between">
                  <dt class="text-muted text-small">Open invoices</dt>
                  <dd id="summary-open-invoices">0</dd>
                </div>
                <div class="flex justify-between">
                  <dt class="text-muted text-small">Payments this month</dt>
                  <dd id="summary-month-payments">$0.00</dd>
                </div>
              </dl>
            </div>
            <div class="card col-span-1 lg:col-span-2">
              <h2>Notifications</h2>
              <ul id="dashboard-notifications" class="list-plain mt-2"></ul>
              <p id="dashboard-empty-state" class="empty mt-1">
                No new notifications. All systems operating smoothly.
              </p>
            </div>
          </div>
        </section>

        <section id="tab-bookings" class="tab-panel hidden">
          <div class="grid grid-2 gap-md">
            <div class="card">
              <div class="grid grid-2 gap-sm items-center">
                <div>
                  <h2>Booking Calendar</h2>
                  <p class="text-muted text-small mt-1">
                    Select a day to review or add client sessions.
                  </p>
                </div>
                <div class="flex gap-sm justify-end items-center">
                  <button id="calendar-prev" class="btn btn-ghost" type="button" aria-label="Previous month">
                    Prev
                  </button>
                  <span id="calendar-month"></span>
                  <button id="calendar-next" class="btn btn-ghost" type="button" aria-label="Next month">
                    Next
                  </button>
                </div>
              </div>
              <div class="calendar-wrapper">
                <div class="calendar-grid calendar-weekdays text-subtle text-small" aria-label="Calendar weekdays">
                  <div class="text-center">Sun</div>
                  <div class="text-center">Mon</div>
                  <div class="text-center">Tue</div>
                  <div class="text-center">Wed</div>
                  <div class="text-center">Thu</div>
                  <div class="text-center">Fri</div>
                  <div class="text-center">Sat</div>
                </div>
                <div id="calendar-grid" class="calendar-grid" aria-live="polite"></div>
              </div>
            </div>

            <div class="card grid gap-md">
              <div>
                <h3>Bookings on <span id="selected-date-label">Select a date</span></h3>
                <ul id="booking-list" class="list-plain mt-2"></ul>
                <p id="booking-empty" class="empty mt-1">No bookings scheduled yet.</p>
              </div>
              <form
                id="booking-form"
                class="grid gap-sm"
                autocomplete="off"
                aria-labelledby="booking-form-title"
              >
                <div class="flex justify-between items-center">
                  <h4 id="booking-form-title">Add booking</h4>
                  <button
                    id="booking-cancel-edit"
                    type="button"
                    class="btn btn-ghost btn-sm hidden"
                  >
                    Cancel edit
                  </button>
                </div>
                <div class="form-field">
                  <label class="form-label" for="booking-client">Client name</label>
                  <input
                    id="booking-client"
                    type="text"
                    name="client"
                    required
                    placeholder="Client name"
                  />
                </div>
                <div class="form-field">
                  <label class="form-label" for="booking-service">Service</label>
                  <input
                    id="booking-service"
                    type="text"
                    name="service"
                    required
                    placeholder="Service description"
                  />
                </div>
                <div class="form-field">
                  <label class="form-label" for="booking-start">Start time</label>
                  <input id="booking-start" type="time" name="startTime" required />
                </div>
                <div class="form-field">
                  <label class="form-label" for="booking-end">End time</label>
                  <input id="booking-end" type="time" name="endTime" required />
                </div>
                <div class="form-field">
                  <label class="form-label" for="booking-status">Status</label>
                  <select id="booking-status" name="status">
                    <option value="confirmed">Confirmed</option>
                    <option value="pending">Pending</option>
                    <option value="completed">Completed</option>
                    <option value="cancelled">Cancelled</option>
                  </select>
                </div>
                <button type="submit" class="btn btn-primary">Save booking</button>
              </form>
            </div>
          </div>
        </section>

        <section id="tab-payments" class="tab-panel hidden">
          <div class="grid grid-2 gap-md">
            <div class="card">
              <div class="flex justify-between items-center">
                <h2>Invoices</h2>
                <button id="generate-invoice" class="btn btn-primary" type="button">
                  Generate PDF Invoice
                </button>
              </div>
              <table class="table mt-2" aria-label="Invoices table">
                <thead>
                  <tr>
                    <th scope="col">Invoice #</th>
                    <th scope="col">Booking</th>
                    <th scope="col">Amount</th>
                    <th scope="col">Status</th>
                    <th scope="col">Due date</th>
                    <th scope="col">Actions</th>
                  </tr>
                </thead>
                <tbody id="invoice-table"></tbody>
              </table>
              <p id="invoice-empty" class="empty mt-1">No invoices available. Create one from a booking.</p>
            </div>

            <div class="card">
              <h2>Payments</h2>
              <table class="table mt-2" aria-label="Payments table">
                <thead>
                  <tr>
                    <th scope="col">Date</th>
                    <th scope="col">Client</th>
                    <th scope="col">Amount</th>
                    <th scope="col">Method</th>
                    <th scope="col">Reference</th>
                    <th scope="col">Actions</th>
                  </tr>
                </thead>
                <tbody id="payments-table"></tbody>
              </table>
              <p id="payments-empty" class="empty mt-1">No payments recorded yet.</p>
            </div>

            <div class="card">
              <h3 id="invoice-form-title">Create invoice</h3>
              <form
                id="invoice-form"
                class="grid gap-sm mt-1"
                autocomplete="off"
                aria-labelledby="invoice-form-title"
              >
                <div class="flex justify-between items-center gap-sm">
                  <div class="form-field flex-1">
                    <label class="form-label" for="invoice-booking">Booking</label>
                    <select id="invoice-booking" name="bookingId" required></select>
                  </div>
                  <button
                    id="invoice-cancel-edit"
                    type="button"
                    class="btn btn-ghost btn-sm hidden"
                  >
                    Cancel edit
                  </button>
                </div>
                <div class="form-field">
                  <label class="form-label" for="invoice-amount">Amount</label>
                  <input
                    id="invoice-amount"
                    type="number"
                    name="amount"
                    step="0.01"
                    min="0"
                    required
                    placeholder="0.00"
                  />
                </div>
                <div class="form-field">
                  <label class="form-label" for="invoice-due">Due date</label>
                  <input id="invoice-due" type="date" name="dueDate" required />
                </div>
                <button type="submit" class="btn btn-primary">Save invoice</button>
              </form>
            </div>

            <div class="card">
              <h3 id="payment-form-title">Record payment</h3>
              <form
                id="payment-form"
                class="grid gap-sm mt-1"
                autocomplete="off"
                aria-labelledby="payment-form-title"
              >
                <div class="flex justify-between items-center gap-sm">
                  <div class="form-field flex-1">
                    <label class="form-label" for="payment-client">Client</label>
                    <input
                      id="payment-client"
                      type="text"
                      name="client"
                      required
                      placeholder="Client name"
                    />
                  </div>
                  <button
                    id="payment-cancel-edit"
                    type="button"
                    class="btn btn-ghost btn-sm hidden"
                  >
                    Cancel edit
                  </button>
                </div>
                <div class="form-field">
                  <label class="form-label" for="payment-date">Payment date</label>
                  <input id="payment-date" type="date" name="date" required />
                </div>
                <div class="form-field">
                  <label class="form-label" for="payment-amount">Amount</label>
                  <input
                    id="payment-amount"
                    type="number"
                    name="amount"
                    step="0.01"
                    min="0"
                    required
                    placeholder="0.00"
                  />
                </div>
                <div class="form-field">
                  <label class="form-label" for="payment-method">Method</label>
                  <select id="payment-method" name="method">
                    <option value="Card">Card</option>
                    <option value="Cash">Cash</option>
                    <option value="Transfer">Transfer</option>
                    <option value="Other">Other</option>
                  </select>
                </div>
                <div class="form-field">
                  <label class="form-label" for="payment-reference">Reference</label>
                  <input
                    id="payment-reference"
                    type="text"
                    name="reference"
                    placeholder="Optional reference"
                  />
                </div>
                <button type="submit" class="btn btn-primary">Save payment</button>
              </form>
            </div>
          </div>
        </section>

        <section id="tab-reports" class="tab-panel hidden">
          <div class="grid grid-2 gap-md">
            <div class="card">
              <h2>Revenue trend</h2>
              <div class="mt-2 relative h-72 w-full">
                <canvas
                  id="revenue-chart"
                  class="absolute inset-0 h-full w-full"
                  role="img"
                  aria-label="Monthly revenue trend chart"
                  aria-describedby="revenue-chart-summary report-highlights"
                ></canvas>
              </div>

              <p id="revenue-chart-summary" class="visually-hidden">
                Revenue trend chart with no data yet.
              </p>
              <p id="revenue-chart-empty" class="empty mt-1">
                Add payments to generate the revenue chart.
              </p>
            </div>
            <div class="card">
              <h2>Highlights</h2>
              <ul id="report-highlights" class="list-plain mt-2"></ul>
              <p id="report-empty" class="empty mt-1">
                When payments are logged the highlights will appear here.
              </p>
            </div>
          </div>
          <div class="card flex flex-wrap gap-sm mt-2">
            <button class="btn" data-export="bookings" type="button">Export bookings CSV</button>
            <button class="btn" data-export="invoices" type="button">Export invoices CSV</button>
            <button class="btn" data-export="payments" type="button">Export payments CSV</button>
          </div>
        </section>

        <section id="tab-settings" class="tab-panel hidden">
          <div class="grid grid-2 gap-md">
            <div class="card">
              <h2 id="settings-form-title">Brand identity</h2>
              <form
                id="settings-form"
                class="grid gap-sm mt-1"
                autocomplete="off"
                aria-labelledby="settings-form-title"
              >
                <div class="form-field">
                  <label class="form-label" for="settings-name">Business name</label>
                  <input id="settings-name" type="text" name="name" required />
                </div>
                <div class="form-field">
                  <label class="form-label" for="settings-email">Support email</label>
                  <input id="settings-email" type="email" name="email" required />
                </div>
                <div class="form-field">
                  <label class="form-label" for="settings-phone">Phone</label>
                  <input id="settings-phone" type="text" name="phone" />
                </div>
                <div class="form-field">
                  <label class="form-label" for="settings-color">Accent color</label>
                  <input id="settings-color" type="color" name="color" />
                </div>
                <div class="form-field">
                  <label class="form-label" for="settings-address">Address</label>
                  <textarea id="settings-address" name="address" rows="3"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">Update branding</button>
              </form>
            </div>
            <div class="card">
              <h3>Brand preview</h3>
              <div id="brand-preview" class="brand-preview mt-1">
                <img
                  src="Zantra_Bookings_Logo.png"
                  alt="Zantra Bookings Logo"
                  class="brand-logo brand-preview-logo"
                />
                <h4 id="brand-preview-name" class="text-[1.35rem] font-semibold">Zantra Studios</h4>
                <p id="brand-preview-email" class="text-muted">team@zantra.com</p>
                <p id="brand-preview-phone" class="text-muted">+1 (555) 123-4567</p>
                <p id="brand-preview-address" class="text-small text-muted mt-1">
                  123 Market Street, Suite 400, San Francisco, CA
                </p>
              </div>
              <div class="text-muted text-small mt-2">
                <p class="mt-0">Tips:</p>
                <ul class="mt-1 ml-5 list-disc space-y-1">
                  <li>Keep the accent colour aligned with your design system.</li>
                  <li>Ensure support details stay current for invoices.</li>
                  <li>Update settings before exporting PDFs to refresh branding.</li>
                </ul>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>
    <script id="core.js">
      (function () {
        "use strict";

        const safeClone = globalThis.structuredClone ?? ((obj) =>
          JSON.parse(JSON.stringify(obj))
        );

        const DateUtils = (() => {
          const pad = (value) => String(value).padStart(2, "0");
          const toIso = (date) => {
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) return "";
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
          };
          const fromIso = (value) => {
            if (typeof value !== "string") return null;
            const parts = value.split("-");
            if (parts.length !== 3) return null;
            const [yearStr, monthStr, dayStr] = parts;
            const year = Number(yearStr);
            const monthIndex = Number(monthStr) - 1;
            const day = Number(dayStr);
            if (
              !Number.isInteger(year) ||
              !Number.isInteger(monthIndex) ||
              !Number.isInteger(day)
            ) {
              return null;
            }
            const candidate = new Date(year, monthIndex, day);
            if (
              candidate.getFullYear() !== year ||
              candidate.getMonth() !== monthIndex ||
              candidate.getDate() !== day
            ) {
              return null;
            }
            return candidate;
          };
          const todayIso = () => toIso(new Date());
          const display = (isoString) => {
            const parsed = fromIso(isoString);
            if (!parsed) return "â€”";
            return parsed.toLocaleDateString(undefined, {
              month: "short",
              day: "numeric",
              year: "numeric",
            });
          };
          return { toIso, fromIso, todayIso, display };
        })();

        const TextUtils = (() => {
          const FALLBACK = "zantra";
          const sanitizeFileSegment = (value, fallback = FALLBACK) => {
            const lower = String(value ?? "").toLowerCase();
            const sanitized = lower
              .replace(/[^a-z0-9_-]+/g, "-")
              .replace(/-+/g, "-")
              .replace(/^[-_]+|[-_]+$/g, "");
            return sanitized || fallback;
          };
          const escapeCsvCell = (value) => {
            const stringValue = String(value ?? "");
            const cleaned = stringValue.replace(/\r\n|\n|\r/g, " ");
            const leadingWhitespaceMatch = cleaned.match(/^\s*/);
            const leadingWhitespace = leadingWhitespaceMatch ? leadingWhitespaceMatch[0] : "";
            const trimmed = cleaned.slice(leadingWhitespace.length);
            const needsQuotePrefix = /^[=+\-@]/.test(trimmed);
            const safeValue = needsQuotePrefix ? `${leadingWhitespace}'${trimmed}` : cleaned;
            const escaped = safeValue.replace(/"/g, '""');
            return `"${escaped}"`;
          };
          return { sanitizeFileSegment, escapeCsvCell };
        })();

        const Toast = (() => {
          const region = document.getElementById("toast-region");
          const timers = new WeakMap();
          const maxVisible = 6;
          const allowedTones = new Set(["success", "error", "warning", "info"]);

          const removeToast = (toast) => {
            if (!toast) return;
            const existing = timers.get(toast);
            if (existing?.hideTimer) window.clearTimeout(existing.hideTimer);
            if (existing?.removeTimer) window.clearTimeout(existing.removeTimer);
            toast.classList.remove("visible");
            const removeTimer = window.setTimeout(() => {
              toast.remove();
              timers.delete(toast);
            }, 250);
            timers.set(toast, { hideTimer: null, removeTimer });
          };

          const queueRemoval = (toast, duration) => {
            const hideTimer = window.setTimeout(() => removeToast(toast), Math.max(duration, 2000));
            timers.set(toast, { hideTimer, removeTimer: null });
          };

          const show = (message, tone = "info", options = {}) => {
            if (!region) return;
            const text = typeof message === "string" ? message.trim() : String(message ?? "").trim();
            if (!text) return;
            const resolvedTone = allowedTones.has(tone) ? tone : "info";
            const toast = document.createElement("div");
            toast.className = "toast";
            toast.dataset.tone = resolvedTone;
            toast.setAttribute("role", "alert");
            toast.textContent = text;
            if (region.children.length >= maxVisible) {
              removeToast(region.lastElementChild);
            }
            region.prepend(toast);
            requestAnimationFrame(() => toast.classList.add("visible"));
            const duration = Number.isFinite(options.duration) ? options.duration : 5000;
            if (duration !== Infinity) {
              queueRemoval(toast, duration);
            } else {
              timers.set(toast, { hideTimer: null, removeTimer: null });
            }
            toast.addEventListener("click", () => removeToast(toast));
          };

          return { show };
        })();

        const Theme = (() => {
          const FALLBACK = "#8b5cf6";
          const normalize = (value) => {
            if (typeof value !== "string") return FALLBACK;
            const trimmed = value.trim();
            if (!/^#?[0-9a-f]{3,6}$/i.test(trimmed)) return FALLBACK;
            let hex = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
            if (hex.length === 3) {
              hex = hex
                .split("")
                .map((char) => char + char)
                .join("");
            }
            return `#${hex.slice(0, 6)}`;
          };
          const hexToRgb = (hex) => {
            if (!/^#[0-9a-f]{6}$/i.test(hex)) return null;
            const value = hex.slice(1);
            const bigint = parseInt(value, 16);
            return [
              (bigint >> 16) & 255,
              (bigint >> 8) & 255,
              bigint & 255,
            ];
          };
          const setAccent = (value) => {
            const normalized = normalize(value);
            document.documentElement.style.setProperty("--brand-accent", normalized);
            const rgb = hexToRgb(normalized);
            if (rgb) {
              document.documentElement.style.setProperty("--brand-accent-rgb", rgb.join(", "));
            }
          };
          setAccent(FALLBACK);
          return { setAccent };
        })();

        window.ZantraCore = Object.freeze({
          safeClone,
          DateUtils,
          TextUtils,
          Toast,
          Theme,
        });
      })();
    </script>
    <script>
      (function () {
        "use strict";

        const core = window.ZantraCore;
        if (!core) {
          throw new Error("Zantra core utilities failed to load.");
        }
        const { safeClone, DateUtils, TextUtils, Toast, Theme } = core;

        const defaultState = {
          bookings: [],
          invoices: [],
          payments: [],
          settings: {
            id: "settings",
            name: "Zantra Studios",
            email: "team@zantra.com",
            phone: "+1 (555) 123-4567",
            color: "#8b5cf6",
            address: "123 Market Street, Suite 400, San Francisco, CA",
            updatedAt: new Date().toISOString(),
            dirty: false,
            userId: null,
          },
        };

        const Database = (() => {
          const STORE_NAMES = ["bookings", "invoices", "payments", "settings"];
          const DB_NAME = "zantra_console_v1";
          const DB_VERSION = 2;
          const isSupported = typeof indexedDB !== "undefined";

          const memoryStores = STORE_NAMES.reduce((acc, name) => {
            acc.set(name, new Map());
            return acc;
          }, new Map());

          let openPromise = null;

          const ensureStoreIndexes = (store) => {
            if (!store) return;
            if (!store.indexNames.contains("dirty")) {
              store.createIndex("dirty", "dirty", { unique: false });
            }
            if (!store.indexNames.contains("updatedAt")) {
              store.createIndex("updatedAt", "updatedAt", { unique: false });
            }
          };

          const openDb = () => {
            if (!isSupported) return Promise.resolve(null);
            if (openPromise) return openPromise;
            openPromise = new Promise((resolve, reject) => {
              const request = indexedDB.open(DB_NAME, DB_VERSION);
              request.onerror = () => {
                reject(request.error || new Error("Unable to open IndexedDB."));
              };
              request.onupgradeneeded = (event) => {
                const db = event.target.result;
                const upgradeTransaction = event.target.transaction || request.transaction;
                STORE_NAMES.forEach((name) => {
                  let store = null;
                  if (!db.objectStoreNames.contains(name)) {
                    store = db.createObjectStore(name, { keyPath: "id" });
                  } else if (upgradeTransaction) {
                    store = upgradeTransaction.objectStore(name);
                  }
                  ensureStoreIndexes(store);
                });
              };
              request.onsuccess = () => {
                const db = request.result;
                db.onversionchange = () => db.close();
                resolve(db);
              };
            });
            return openPromise;
          };

          const getAll = async (storeName) => {
            if (!STORE_NAMES.includes(storeName)) return [];
            if (!isSupported) {
              const store = memoryStores.get(storeName);
              return Array.from(store.values()).map((item) => safeClone(item));
            }
            const db = await openDb();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(storeName, "readonly");
              const store = tx.objectStore(storeName);
              const request = store.getAll();
              request.onsuccess = () => resolve(request.result || []);
              request.onerror = () => reject(request.error || new Error("Failed to read data."));
            });
          };

          const put = async (storeName, value) => {
            if (!STORE_NAMES.includes(storeName) || !value) return;
            if (!isSupported) {
              const store = memoryStores.get(storeName);
              store.set(value.id, safeClone(value));
              return;
            }
            const db = await openDb();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              store.put(value);
              tx.oncomplete = () => resolve();
              tx.onerror = () => reject(tx.error || new Error("Failed to persist record."));
              tx.onabort = () => reject(tx.error || new Error("Transaction aborted."));
            });
          };

          const putMany = async (storeName, values) => {
            if (!Array.isArray(values) || values.length === 0) return;
            if (!STORE_NAMES.includes(storeName)) return;
            if (!isSupported) {
              const store = memoryStores.get(storeName);
              values.forEach((value) => {
                if (value?.id) store.set(value.id, safeClone(value));
              });
              return;
            }
            const db = await openDb();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              values.forEach((value) => {
                if (value?.id) store.put(value);
              });
              tx.oncomplete = () => resolve();
              tx.onerror = () => reject(tx.error || new Error("Failed to persist batch."));
              tx.onabort = () => reject(tx.error || new Error("Transaction aborted."));
            });
          };

          const deleteRecord = async (storeName, key) => {
            if (!STORE_NAMES.includes(storeName)) return;
            if (!isSupported) {
              const store = memoryStores.get(storeName);
              store.delete(key);
              return;
            }
            const db = await openDb();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              store.delete(key);
              tx.oncomplete = () => resolve();
              tx.onerror = () => reject(tx.error || new Error("Failed to delete record."));
              tx.onabort = () => reject(tx.error || new Error("Transaction aborted."));
            });
          };

          const deleteMany = async (storeName, keys) => {
            if (!Array.isArray(keys) || keys.length === 0) return;
            if (!STORE_NAMES.includes(storeName)) return;
            if (!isSupported) {
              const store = memoryStores.get(storeName);
              keys.forEach((key) => store.delete(key));
              return;
            }
            const db = await openDb();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(storeName, "readwrite");
              const store = tx.objectStore(storeName);
              keys.forEach((key) => store.delete(key));
              tx.oncomplete = () => resolve();
              tx.onerror = () => reject(tx.error || new Error("Failed to delete batch."));
              tx.onabort = () => reject(tx.error || new Error("Transaction aborted."));
            });
          };

          const getDirty = async (storeName) => {
            if (!STORE_NAMES.includes(storeName)) return [];
            if (!isSupported) {
              const store = memoryStores.get(storeName);
              return Array.from(store.values()).filter((item) => item?.dirty);
            }
            const db = await openDb();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(storeName, "readonly");
              const store = tx.objectStore(storeName);
              let request = null;
              if (store.indexNames.contains("dirty")) {
                const index = store.index("dirty");
                request = index.getAll(IDBKeyRange.only(true));
              } else {
                request = store.getAll();
              }
              request.onsuccess = () => {
                const result = request.result || [];
                if (!store.indexNames.contains("dirty")) {
                  resolve(result.filter((item) => item?.dirty));
                } else {
                  resolve(result);
                }
              };
              request.onerror = () => reject(request.error || new Error("Failed to query dirty records."));
            });
          };

          const clearStore = async (storeName) => {
            if (!STORE_NAMES.includes(storeName)) return;
            if (!isSupported) {
              memoryStores.get(storeName).clear();
              return;
            }
            const db = await openDb();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(storeName, "readwrite");
              tx.objectStore(storeName).clear();
              tx.oncomplete = () => resolve();
              tx.onerror = () => reject(tx.error || new Error("Failed to clear store."));
              tx.onabort = () => reject(tx.error || new Error("Transaction aborted."));
            });
          };

          return Object.freeze({
            init: openDb,
            getAll,
            put,
            putMany,
            delete: deleteRecord,
            deleteMany,
            getDirty,
            clearStore,
            isSupported: () => isSupported,
          });
        })();

        const AppStore = (() => {
          const prefixMap = {
            bookings: "booking",
            invoices: "invoice",
            payments: "payment",
            settings: "settings",
          };

          const memory = {
            bookings: [],
            invoices: [],
            payments: [],
            settings: safeClone(defaultState.settings),
          };

          let ready = false;

          const randomId = (prefix) => {
            const unique =
              typeof crypto !== "undefined" && typeof crypto.randomUUID === "function"
                ? crypto.randomUUID()
                : `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
            return `${prefix}_${unique}`;
          };

          const normalizeRecord = (record, storeName) => {
            const copy = Object.assign({}, record || {});
            const prefix = prefixMap[storeName] || "record";
            if (!copy.id) copy.id = storeName === "settings" ? "settings" : randomId(prefix);
            const remoteUpdatedAt = copy.updated_at || copy.updatedAt;
            copy.updatedAt =
              typeof remoteUpdatedAt === "string" && remoteUpdatedAt
                ? remoteUpdatedAt
                : new Date().toISOString();
            copy.dirty = Boolean(copy.dirty);
            if (copy.user_id && !copy.userId) copy.userId = copy.user_id;
            if (!copy.userId) copy.userId = null;
            if (storeName === "settings") {
              copy.id = "settings";
            }
            delete copy.user_id;
            delete copy.updated_at;
            return copy;
          };

          const normalizeCollection = (storeName, records) => {
            if (!Array.isArray(records)) return [];
            return records.map((item) => normalizeRecord(item, storeName));
          };

          const ensureReady = () => (ready ? Promise.resolve() : readyPromise);

          const getActiveUserId = () => {
            if (typeof window === "undefined") return null;
            const auth = window.ZantraAuth;
            if (auth && typeof auth.getUserId === "function") {
              return auth.getUserId();
            }
            return null;
          };

          const markDirty = (record) => {
            record.updatedAt = new Date().toISOString();
            record.dirty = true;
            if (!record.userId) {
              record.userId = getActiveUserId();
            }
          };

          const cloneList = (items) => items.map((item) => safeClone(item));

          const readyPromise = (async () => {
            try {
              await Database.init();
              const [bookings, invoices, payments, settings] = await Promise.all([
                Database.getAll("bookings"),
                Database.getAll("invoices"),
                Database.getAll("payments"),
                Database.getAll("settings"),
              ]);
              memory.bookings = normalizeCollection("bookings", bookings);
              memory.invoices = normalizeCollection("invoices", invoices);
              memory.payments = normalizeCollection("payments", payments);
              if (Array.isArray(settings) && settings.length > 0) {
                memory.settings = normalizeRecord(settings[0], "settings");
              } else {
                memory.settings = normalizeRecord(defaultState.settings, "settings");
                memory.settings.dirty = false;
                await Database.put("settings", memory.settings);
              }
              const persistOps = [];
              if (memory.bookings.length) {
                persistOps.push(Database.putMany("bookings", memory.bookings));
              }
              if (memory.invoices.length) {
                persistOps.push(Database.putMany("invoices", memory.invoices));
              }
              if (memory.payments.length) {
                persistOps.push(Database.putMany("payments", memory.payments));
              }
              persistOps.push(Database.put("settings", memory.settings));
              await Promise.all(persistOps).catch((error) => {
                console.warn("Failed to normalize stored records", error);
              });
              Theme.setAccent(memory.settings.color || defaultState.settings.color);
            } catch (error) {
              console.error("Failed to load local data", error);
              Toast.show("Local data unavailable. Loaded defaults.", "warning");
              memory.bookings = [];
              memory.invoices = [];
              memory.payments = [];
              memory.settings = normalizeRecord(defaultState.settings, "settings");
              memory.settings.dirty = false;
            } finally {
              ready = true;
            }
          })();

          const startOfToday = () => {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            return today;
          };

          const getCollectionByStore = (storeName) => {
            switch (storeName) {
              case "bookings":
                return memory.bookings;
              case "invoices":
                return memory.invoices;
              case "payments":
                return memory.payments;
              default:
                return [];
            }
          };

          const markClean = async (storeName, payloads) => {
            if (!Array.isArray(payloads) || payloads.length === 0) return;
            await ensureReady();
            if (storeName === "settings") {
              const latest = payloads[payloads.length - 1];
              const normalized = normalizeRecord(latest, "settings");
              normalized.dirty = false;
              memory.settings = Object.assign({}, memory.settings, normalized, { dirty: false });
              await Database.put("settings", memory.settings);
              Theme.setAccent(memory.settings.color || defaultState.settings.color);
              return;
            }
            const target = getCollectionByStore(storeName);
            const updates = [];
            payloads.forEach((entry) => {
              const normalized = normalizeRecord(entry, storeName);
              normalized.dirty = false;
              const index = target.findIndex((item) => item.id === normalized.id);
              if (index === -1) {
                target.push(normalized);
              } else {
                target[index] = Object.assign({}, target[index], normalized, { dirty: false });
              }
              updates.push(normalized);
            });
            if (updates.length) {
              await Database.putMany(storeName, updates);
            }
          };

          const api = {
            ready: () => ensureReady(),
            get settings() {
              return safeClone(memory.settings);
            },
            async updateSettings(updates) {
              await ensureReady();
              const next = Object.assign({}, memory.settings, updates);
              markDirty(next);
              memory.settings = next;
              await Database.put("settings", memory.settings);
              Theme.setAccent(memory.settings.color || defaultState.settings.color);
              return safeClone(memory.settings);
            },
            async addBooking(booking) {
              await ensureReady();
              const entry = normalizeRecord(
                Object.assign({ id: randomId("booking") }, booking),
                "bookings"
              );
              markDirty(entry);
              memory.bookings.push(entry);
              await Database.put("bookings", entry);
              return safeClone(entry);
            },
            async updateBooking(id, updates) {
              await ensureReady();
              const index = memory.bookings.findIndex((item) => item.id === id);
              if (index === -1) return null;
              const updated = Object.assign({}, memory.bookings[index], updates);
              markDirty(updated);
              memory.bookings[index] = updated;
              await Database.put("bookings", updated);
              return safeClone(updated);
            },
            async removeBooking(id) {
              await ensureReady();
              const index = memory.bookings.findIndex((item) => item.id === id);
              if (index === -1) return false;
              memory.bookings.splice(index, 1);
              await Database.delete("bookings", id);
              const linkedInvoices = memory.invoices.filter((invoice) => invoice.bookingId === id);
              if (linkedInvoices.length > 0) {
                const removalIds = linkedInvoices.map((invoice) => invoice.id);
                memory.invoices = memory.invoices.filter((invoice) => invoice.bookingId !== id);
                await Database.deleteMany("invoices", removalIds);
              }
              return true;
            },
            getBookingsByDate(iso) {
              return memory.bookings
                .filter((item) => item.date === iso)
                .map((item) => safeClone(item));
            },
            getAllBookings() {
              return cloneList(memory.bookings);
            },
            getBookingById(id) {
              const found = memory.bookings.find((item) => item.id === id);
              return found ? safeClone(found) : null;
            },
            getUpcomingBookings() {
              const today = startOfToday();
              return memory.bookings
                .filter((item) => {
                  const parsed = DateUtils.fromIso(item.date);
                  if (!parsed) return false;
                  parsed.setHours(0, 0, 0, 0);
                  return parsed.getTime() >= today.getTime();
                })
                .sort((a, b) => {
                  const dateA = DateUtils.fromIso(a.date);
                  const dateB = DateUtils.fromIso(b.date);
                  if (dateA && dateB) {
                    const diff = dateA.getTime() - dateB.getTime();
                    if (diff !== 0) return diff;
                  } else if (dateA) {
                    return -1;
                  } else if (dateB) {
                    return 1;
                  }
                  return a.startTime.localeCompare(b.startTime);
                })
                .slice(0, 5)
                .map((item) => safeClone(item));
            },
            async addInvoice(invoice) {
              await ensureReady();
              const entry = normalizeRecord(
                Object.assign({ id: randomId("invoice") }, invoice),
                "invoices"
              );
              markDirty(entry);
              memory.invoices.push(entry);
              await Database.put("invoices", entry);
              return safeClone(entry);
            },
            async updateInvoice(id, updates) {
              await ensureReady();
              const index = memory.invoices.findIndex((item) => item.id === id);
              if (index === -1) return null;
              const updated = Object.assign({}, memory.invoices[index], updates);
              markDirty(updated);
              memory.invoices[index] = updated;
              await Database.put("invoices", updated);
              return safeClone(updated);
            },
            async updateInvoiceStatus(id, status) {
              return this.updateInvoice(id, { status });
            },
            async removeInvoice(id) {
              await ensureReady();
              const before = memory.invoices.length;
              memory.invoices = memory.invoices.filter((item) => item.id !== id);
              if (before === memory.invoices.length) return false;
              await Database.delete("invoices", id);
              return true;
            },
            getInvoices() {
              return cloneList(memory.invoices);
            },
            getInvoiceById(id) {
              const found = memory.invoices.find((item) => item.id === id);
              return found ? safeClone(found) : null;
            },
            getOpenInvoices() {
              return memory.invoices
                .filter((invoice) => invoice.status !== "paid")
                .map((invoice) => safeClone(invoice));
            },
            async addPayment(payment) {
              await ensureReady();
              const entry = normalizeRecord(
                Object.assign({ id: randomId("payment") }, payment),
                "payments"
              );
              markDirty(entry);
              memory.payments.push(entry);
              await Database.put("payments", entry);
              return safeClone(entry);
            },
            async updatePayment(id, updates) {
              await ensureReady();
              const index = memory.payments.findIndex((item) => item.id === id);
              if (index === -1) return null;
              const updated = Object.assign({}, memory.payments[index], updates);
              markDirty(updated);
              memory.payments[index] = updated;
              await Database.put("payments", updated);
              return safeClone(updated);
            },
            async removePayment(id) {
              await ensureReady();
              const before = memory.payments.length;
              memory.payments = memory.payments.filter((item) => item.id !== id);
              if (before === memory.payments.length) return false;
              await Database.delete("payments", id);
              return true;
            },
            getPayments() {
              return cloneList(memory.payments);
            },
            getPaymentById(id) {
              const found = memory.payments.find((item) => item.id === id);
              return found ? safeClone(found) : null;
            },
            getPaymentsForMonth(year, monthIndex) {
              return memory.payments
                .filter((payment) => {
                  const parsed = DateUtils.fromIso(payment.date);
                  return parsed && parsed.getFullYear() === year && parsed.getMonth() === monthIndex;
                })
                .map((item) => safeClone(item));
            },
            async getDirtyRecords() {
              await ensureReady();
              const [bookings, invoices, payments, settings] = await Promise.all([
                Database.getDirty("bookings"),
                Database.getDirty("invoices"),
                Database.getDirty("payments"),
                Database.getDirty("settings"),
              ]);
              return {
                bookings: normalizeCollection("bookings", bookings),
                invoices: normalizeCollection("invoices", invoices),
                payments: normalizeCollection("payments", payments),
                settings: normalizeCollection("settings", settings),
              };
            },
            async markRecordsClean(storeName, payloads) {
              await markClean(storeName, payloads);
            },
            async mergeRemoteRecords(storeName, payloads) {
              if (!Array.isArray(payloads) || payloads.length === 0) return;
              await ensureReady();
              if (storeName === "settings") {
                const remote = normalizeRecord(payloads[payloads.length - 1], "settings");
                const currentTime = Date.parse(memory.settings.updatedAt || 0) || 0;
                const remoteTime = Date.parse(remote.updatedAt || 0) || 0;
                if (remoteTime >= currentTime) {
                  remote.dirty = false;
                  memory.settings = Object.assign({}, memory.settings, remote, { dirty: false });
                  await Database.put("settings", memory.settings);
                  Theme.setAccent(memory.settings.color || defaultState.settings.color);
                }
                return;
              }
              const target = getCollectionByStore(storeName);
              const updates = [];
              payloads.forEach((payload) => {
                const normalized = normalizeRecord(payload, storeName);
                normalized.dirty = false;
                const index = target.findIndex((item) => item.id === normalized.id);
                if (index === -1) {
                  target.push(normalized);
                  updates.push(normalized);
                  return;
                }
                const existing = target[index];
                const existingTime = Date.parse(existing.updatedAt || 0) || 0;
                const remoteTime = Date.parse(normalized.updatedAt || 0) || 0;
                if (remoteTime >= existingTime) {
                  const merged = Object.assign({}, existing, normalized, { dirty: false });
                  target[index] = merged;
                  updates.push(merged);
                }
              });
              if (updates.length) {
                await Database.putMany(storeName, updates);
              }
            },
          };

          return Object.freeze(api);
        })();

        const Tabs = (() => {
          const buttons = Array.from(document.querySelectorAll(".tab-button"));
          const panels = Array.from(document.querySelectorAll(".tab-panel"));

          const show = (name) => {
            buttons.forEach((button) => {
              const isActive = button.dataset.tab === name;
              button.classList.toggle("active", isActive);
              button.setAttribute("aria-selected", String(isActive));
              button.tabIndex = isActive ? 0 : -1;
            });
            panels.forEach((panel) => {
              panel.classList.toggle("hidden", panel.id !== `tab-${name}`);
            });
          };

          buttons.forEach((button) =>
            button.addEventListener("click", () => show(button.dataset.tab))
          );

          return { show };
        })();

        const Calendar = (() => {
          const grid = document.getElementById("calendar-grid");
          const monthLabel = document.getElementById("calendar-month");
          const selectedLabel = document.getElementById("selected-date-label");
          const bookingList = document.getElementById("booking-list");
          const bookingEmpty = document.getElementById("booking-empty");
          const prevBtn = document.getElementById("calendar-prev");
          const nextBtn = document.getElementById("calendar-next");
          const form = document.getElementById("booking-form");
          const cancelEditBtn = document.getElementById("booking-cancel-edit");
          const submitBtn = form.querySelector('button[type="submit"]');

          let activeDate = new Date();
          let selectedIso = null;
          let editingId = null;

          const requestSync = (reason) => {
            const sync = window.ZantraSync;
            if (sync && typeof sync.trigger === "function") {
              sync.trigger(reason).catch(() => {});
            }
          };

          const setDefaultBookingTimes = (force = false) => {
            if (!selectedIso || editingId) return;
            const startField = document.getElementById("booking-start");
            const endField = document.getElementById("booking-end");
            if (!startField || !endField) return;
            const selectedDate = DateUtils.fromIso(selectedIso) || new Date();
            const start = new Date(selectedDate);
            start.setHours(9, 0, 0, 0);
            const end = new Date(selectedDate);
            end.setHours(10, 0, 0, 0);
            const format = (date) => `${String(date.getHours()).padStart(2, "0")}:${String(date.getMinutes()).padStart(2, "0")}`;
            if (force || !startField.value) startField.value = format(start);
            if (force || !endField.value) endField.value = format(end);
          };

          const renderCalendar = () => {
            const year = activeDate.getFullYear();
            const month = activeDate.getMonth();
            const first = new Date(year, month, 1);
            const last = new Date(year, month + 1, 0);

            monthLabel.textContent = activeDate.toLocaleDateString(undefined, {
              month: "long",
              year: "numeric",
            });

            grid.innerHTML = "";
            for (let i = 0; i < first.getDay(); i += 1) {
              const placeholder = document.createElement("div");
              placeholder.setAttribute("aria-hidden", "true");
              grid.appendChild(placeholder);
            }

            for (let day = 1; day <= last.getDate(); day += 1) {
              const current = new Date(year, month, day);
              const iso = DateUtils.toIso(current);
              const cell = document.createElement("button");
              cell.type = "button";
              cell.className = "calendar-cell";
              cell.setAttribute("aria-label", `${current.toDateString()}`);
              if (iso === selectedIso) cell.classList.add("active");
              const strong = document.createElement("strong");
              strong.textContent = String(day);
              const count = document.createElement("span");
              count.className = "text-subtle text-xs";
              const bookingsCount = AppStore.getBookingsByDate(iso).length;
              count.textContent = `${bookingsCount} booking${bookingsCount === 1 ? "" : "s"}`;
              cell.append(strong, count);
              cell.addEventListener("click", () => selectDate(iso));
              grid.appendChild(cell);
            }
          };

          const resetFormState = () => {
            editingId = null;
            form.reset();
            submitBtn.textContent = "Save booking";
            cancelEditBtn.classList.add("hidden");
            form.removeAttribute("data-editing-id");
            setDefaultBookingTimes(true);
          };

          const renderBookings = () => {
            bookingList.innerHTML = "";
            if (!selectedIso) {
              bookingEmpty.classList.remove("hidden");
              return;
            }
            const bookings = AppStore.getBookingsByDate(selectedIso).sort((a, b) =>
              a.startTime.localeCompare(b.startTime)
            );
            if (bookings.length === 0) {
              bookingEmpty.classList.remove("hidden");
              return;
            }
            bookingEmpty.classList.add("hidden");
            bookings.forEach((booking) => {
              const item = document.createElement("li");
              const headerRow = document.createElement("div");
              headerRow.className = "flex justify-between items-center";

              const client = document.createElement("span");
              client.textContent = booking.client;
              client.classList.add("font-semibold");

              const badge = document.createElement("span");
              badge.className =
                booking.status === "confirmed"
                  ? "badge badge-confirmed"
                  : booking.status === "pending"
                  ? "badge badge-pending"
                  : "badge badge-default";
              badge.textContent = booking.status;

              headerRow.append(client, badge);

              const service = document.createElement("div");
              service.className = "text-muted text-small";
              service.textContent = booking.service;

              const timing = document.createElement("div");
              timing.className = "text-subtle text-xs";
              timing.textContent = `${DateUtils.display(booking.date)} â€¢ ${booking.startTime} - ${booking.endTime}`;

              const actions = document.createElement("div");
              actions.className = "table-actions";

              const editBtn = document.createElement("button");
              editBtn.type = "button";
              editBtn.className = "btn btn-ghost btn-sm";
              editBtn.textContent = "Edit";
              editBtn.addEventListener("click", () => {
                editingId = booking.id;
                form.dataset.editingId = booking.id;
                submitBtn.textContent = "Update booking";
                cancelEditBtn.classList.remove("hidden");
                form.client.value = booking.client;
                form.service.value = booking.service;
                form.startTime.value = booking.startTime;
                form.endTime.value = booking.endTime;
                form.status.value = booking.status;
                document.getElementById("booking-client").focus();
              });

              const deleteBtn = document.createElement("button");
              deleteBtn.type = "button";
              deleteBtn.className = "btn btn-ghost btn-sm";
              deleteBtn.textContent = "Delete";
              deleteBtn.addEventListener("click", async () => {
                const removed = await AppStore.removeBooking(booking.id);
                if (!removed) return;
                if (editingId === booking.id) {
                  resetFormState();
                }
                renderCalendar();
                renderBookings();
                Dashboard.refresh();
                Payments.refreshAll();
                Reports.render();
                Toast.show("Booking removed.", "success");
                requestSync("booking-delete");
              });

              actions.append(editBtn, deleteBtn);

              item.append(headerRow, service, timing, actions);
              bookingList.appendChild(item);
            });
          };

          const selectDate = (iso, options = {}) => {
            if (!iso) return;
            const previousIso = selectedIso;
            selectedIso = iso;
            selectedLabel.textContent = DateUtils.display(iso);
            if (editingId) {
              const editingBooking = AppStore.getBookingById(editingId);
              if (!editingBooking || editingBooking.date !== iso) {
                resetFormState();
              }
            }
            renderCalendar();
            renderBookings();
            const shouldForce = Boolean(options.forceTimes) || previousIso !== iso;
            if (!editingId) {
              setDefaultBookingTimes(shouldForce);
            }
          };

          form.addEventListener("submit", async (event) => {
            event.preventDefault();
            if (!selectedIso) {
              Toast.show("Select a date on the calendar before adding a booking.", "error");
              return;
            }
            const formData = new FormData(form);
            const client = String(formData.get("client") || "").trim();
            const service = String(formData.get("service") || "").trim();
            const startTime = String(formData.get("startTime") || "").trim();
            const endTime = String(formData.get("endTime") || "").trim();
            const status = String(formData.get("status") || "confirmed");
            if (!client || !service) {
              Toast.show("Client and service are required.", "error");
              return;
            }
            if (endTime <= startTime) {
              Toast.show("End time must be after start time.", "error");
              return;
            }
            try {
              if (editingId) {
                await AppStore.updateBooking(editingId, {
                  client,
                  service,
                  startTime,
                  endTime,
                  status,
                  date: selectedIso,
                });
                Toast.show(`Booking updated for ${DateUtils.display(selectedIso)}.`, "success");
              } else {
                await AppStore.addBooking({
                  date: selectedIso,
                  client,
                  service,
                  startTime,
                  endTime,
                  status,
                });
                Toast.show(`Booking added for ${DateUtils.display(selectedIso)}.`, "success");
              }
              resetFormState();
              renderCalendar();
              renderBookings();
              Dashboard.refresh();
              Payments.refreshAll();
              Reports.render();
              requestSync("booking-change");
            } catch (error) {
              console.error("Failed to persist booking", error);
              Toast.show("Unable to save booking. Please try again.", "error");
            }
          });

          cancelEditBtn.addEventListener("click", () => {
            resetFormState();
          });

          prevBtn.addEventListener("click", () => {
            activeDate = new Date(activeDate.getFullYear(), activeDate.getMonth() - 1, 1);
            renderCalendar();
          });

          nextBtn.addEventListener("click", () => {
            activeDate = new Date(activeDate.getFullYear(), activeDate.getMonth() + 1, 1);
            renderCalendar();
          });

          document.getElementById("quick-add-booking").addEventListener("click", () => {
            Tabs.show("bookings");
            const today = DateUtils.todayIso();
            const parsed = DateUtils.fromIso(today);
            if (parsed) {
              activeDate = parsed;
              selectDate(today, { forceTimes: true });
            } else {
              setDefaultBookingTimes(true);
            }
            document.getElementById("booking-client").focus();
          });

          return {
            init() {
              const todayIso = DateUtils.todayIso();
              const parsedToday = DateUtils.fromIso(todayIso);
              if (parsedToday) {
                activeDate = parsedToday;
                selectDate(todayIso, { forceTimes: true });
              } else {
                renderCalendar();
                renderBookings();
                setDefaultBookingTimes(true);
              }
            },
            selectDate,
            resetFormState,
            refresh() {
              renderCalendar();
              renderBookings();
            },
          };
        })();

        const Payments = (() => {
          const invoiceForm = document.getElementById("invoice-form");
          const invoiceSelect = invoiceForm.querySelector('select[name="bookingId"]');
          const invoiceTable = document.getElementById("invoice-table");
          const invoiceEmpty = document.getElementById("invoice-empty");
          const invoiceCancelEdit = document.getElementById("invoice-cancel-edit");
          const invoiceSubmit = invoiceForm.querySelector('button[type="submit"]');

          const paymentsTable = document.getElementById("payments-table");
          const paymentsEmpty = document.getElementById("payments-empty");
          const paymentForm = document.getElementById("payment-form");
          const paymentCancelEdit = document.getElementById("payment-cancel-edit");
          const paymentSubmit = paymentForm.querySelector('button[type="submit"]');

          let editingInvoiceId = null;
          let editingPaymentId = null;

          const requestSync = (reason) => {
            const sync = window.ZantraSync;
            if (sync && typeof sync.trigger === "function") {
              sync.trigger(reason).catch(() => {});
            }
          };

          const refreshInvoiceOptions = () => {
            const bookings = AppStore.getAllBookings();
            invoiceSelect.innerHTML = "";
            if (bookings.length === 0) {
              const option = document.createElement("option");
              option.textContent = "No bookings available";
              option.value = "";
              option.disabled = true;
              invoiceSelect.appendChild(option);
              invoiceSelect.disabled = true;
              return;
            }
            invoiceSelect.disabled = false;
            bookings.forEach((booking) => {
              const option = document.createElement("option");
              option.value = booking.id;
              option.textContent = `${booking.client} â€” ${DateUtils.display(booking.date)} (${booking.service})`;
              invoiceSelect.appendChild(option);
            });
          };

          const resetInvoiceForm = () => {
            editingInvoiceId = null;
            invoiceForm.reset();
            invoiceSubmit.textContent = "Save invoice";
            invoiceCancelEdit.classList.add("hidden");
            invoiceForm.removeAttribute("data-editing-id");
            refreshInvoiceOptions();
          };

          const resetPaymentForm = () => {
            editingPaymentId = null;
            paymentForm.reset();
            paymentSubmit.textContent = "Save payment";
            paymentCancelEdit.classList.add("hidden");
            paymentForm.removeAttribute("data-editing-id");
            if (paymentForm.date) {
              const today = DateUtils.todayIso();
              paymentForm.date.value = today;
            }
            if (paymentForm.method) {
              paymentForm.method.value = "Card";
            }
          };

          const renderInvoices = () => {
            const invoices = AppStore.getInvoices();
            const bookings = new Map(
              AppStore.getAllBookings().map((booking) => [booking.id, booking])
            );
            invoiceTable.innerHTML = "";
            if (invoices.length === 0) {
              invoiceEmpty.classList.remove("hidden");
            } else {
              invoiceEmpty.classList.add("hidden");
            }
            invoices.forEach((invoice) => {
              const row = document.createElement("tr");

              const numberCell = document.createElement("td");
              numberCell.textContent = invoice.number || "â€”";

              const bookingCell = document.createElement("td");
              const booking = bookings.get(invoice.bookingId);
              bookingCell.textContent = booking
                ? `${booking.client} â€” ${booking.service}`
                : "Booking archived";

              const amountCell = document.createElement("td");
              amountCell.textContent = `$${Number(invoice.amount || 0).toFixed(2)}`;

              const statusCell = document.createElement("td");
              const statusSelect = document.createElement("select");
              statusSelect.dataset.id = invoice.id;
              ["draft", "sent", "paid", "overdue"].forEach((optionValue) => {
                const option = document.createElement("option");
                option.value = optionValue;
                option.textContent = optionValue.charAt(0).toUpperCase() + optionValue.slice(1);
                if (invoice.status === optionValue) option.selected = true;
                statusSelect.appendChild(option);
              });
              statusSelect.addEventListener("change", async (event) => {
                const target = event.target;
                const previous = invoice.status;
                try {
                  await AppStore.updateInvoiceStatus(target.dataset.id, target.value);
                  Dashboard.refresh();
                  Reports.render();
                  Toast.show("Invoice status updated.", "success", { duration: 2500 });
                  requestSync("invoice-status");
                } catch (error) {
                  console.error("Failed to update invoice status", error);
                  Toast.show("Unable to update invoice status.", "error");
                  target.value = previous || "draft";
                }
              });
              statusCell.appendChild(statusSelect);

              const dueDateCell = document.createElement("td");
              dueDateCell.textContent = DateUtils.display(invoice.dueDate);

              const actionsCell = document.createElement("td");
              actionsCell.className = "table-actions";
              const editBtn = document.createElement("button");
              editBtn.type = "button";
              editBtn.className = "btn btn-ghost btn-sm";
              editBtn.textContent = "Edit";
              editBtn.addEventListener("click", () => {
                editingInvoiceId = invoice.id;
                invoiceForm.dataset.editingId = invoice.id;
                invoiceSubmit.textContent = "Update invoice";
                invoiceCancelEdit.classList.remove("hidden");
                refreshInvoiceOptions();
                invoiceSelect.value = invoice.bookingId || "";
                invoiceForm.amount.value = Number(invoice.amount || 0).toFixed(2);
                invoiceForm.dueDate.value = invoice.dueDate || "";
                invoiceSelect.focus();
              });

              const deleteBtn = document.createElement("button");
              deleteBtn.type = "button";
              deleteBtn.className = "btn btn-ghost btn-sm";
              deleteBtn.textContent = "Delete";
              deleteBtn.addEventListener("click", async () => {
                const removed = await AppStore.removeInvoice(invoice.id);
                if (!removed) return;
                if (editingInvoiceId === invoice.id) {
                  resetInvoiceForm();
                }
                renderInvoices();
                Dashboard.refresh();
                Reports.render();
                Toast.show("Invoice removed.", "success");
                requestSync("invoice-delete");
              });

              actionsCell.append(editBtn, deleteBtn);

              row.append(numberCell, bookingCell, amountCell, statusCell, dueDateCell, actionsCell);
              invoiceTable.appendChild(row);
            });
          };

          const renderPayments = () => {
            const payments = AppStore.getPayments();
            paymentsTable.innerHTML = "";
            if (payments.length === 0) {
              paymentsEmpty.classList.remove("hidden");
            } else {
              paymentsEmpty.classList.add("hidden");
            }
            payments.forEach((payment) => {
              const row = document.createElement("tr");

              const dateCell = document.createElement("td");
              dateCell.textContent = DateUtils.display(payment.date);

              const clientCell = document.createElement("td");
              clientCell.textContent = payment.client;

              const amountCell = document.createElement("td");
              amountCell.textContent = `$${Number(payment.amount || 0).toFixed(2)}`;

              const methodCell = document.createElement("td");
              methodCell.textContent = payment.method;

              const referenceCell = document.createElement("td");
              referenceCell.textContent = payment.reference || "â€”";

              const actionsCell = document.createElement("td");
              actionsCell.className = "table-actions";
              const editBtn = document.createElement("button");
              editBtn.type = "button";
              editBtn.className = "btn btn-ghost btn-sm";
              editBtn.textContent = "Edit";
              editBtn.addEventListener("click", () => {
                editingPaymentId = payment.id;
                paymentForm.dataset.editingId = payment.id;
                paymentSubmit.textContent = "Update payment";
                paymentCancelEdit.classList.remove("hidden");
                paymentForm.client.value = payment.client;
                paymentForm.date.value = payment.date || DateUtils.todayIso();
                paymentForm.amount.value = Number(payment.amount || 0).toFixed(2);
                paymentForm.method.value = payment.method;
                paymentForm.reference.value = payment.reference || "";
                document.getElementById("payment-client").focus();
              });

              const deleteBtn = document.createElement("button");
              deleteBtn.type = "button";
              deleteBtn.className = "btn btn-ghost btn-sm";
              deleteBtn.textContent = "Delete";
              deleteBtn.addEventListener("click", async () => {
                const removed = await AppStore.removePayment(payment.id);
                if (!removed) return;
                if (editingPaymentId === payment.id) {
                  resetPaymentForm();
                }
                renderPayments();
                Dashboard.refresh();
                Reports.render();
                Toast.show("Payment removed.", "success");
                requestSync("payment-delete");
              });

              actionsCell.append(editBtn, deleteBtn);

              row.append(dateCell, clientCell, amountCell, methodCell, referenceCell, actionsCell);
              paymentsTable.appendChild(row);
            });
          };

          invoiceForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            if (invoiceSelect.disabled || !invoiceSelect.value) {
              Toast.show("Select a booking before creating an invoice.", "error");
              return;
            }
            const data = new FormData(invoiceForm);
            const amount = Number(data.get("amount"));
            const dueDate = String(data.get("dueDate"));
            if (!Number.isFinite(amount) || amount <= 0) {
              Toast.show("Invoice amount must be greater than zero.", "error");
              return;
            }
            if (!DateUtils.fromIso(dueDate)) {
              Toast.show("Provide a valid due date.", "error");
              return;
            }
            const payload = {
              bookingId: data.get("bookingId"),
              amount,
              dueDate,
              number:
                editingInvoiceId && AppStore.getInvoiceById(editingInvoiceId)
                  ? AppStore.getInvoiceById(editingInvoiceId).number
                  : `INV-${DateUtils.todayIso().replaceAll("-", "")}-${Math.random()
                      .toString(36)
                      .slice(2, 6)
                      .toUpperCase()}`,
              status:
                editingInvoiceId && AppStore.getInvoiceById(editingInvoiceId)
                  ? AppStore.getInvoiceById(editingInvoiceId).status || "draft"
                  : "draft",
            };
            try {
              if (editingInvoiceId) {
                await AppStore.updateInvoice(editingInvoiceId, payload);
                Toast.show("Invoice updated.", "success");
              } else {
                await AppStore.addInvoice(payload);
                Toast.show("Invoice created.", "success");
              }
              resetInvoiceForm();
              renderInvoices();
              Dashboard.refresh();
              Reports.render();
              requestSync("invoice-change");
            } catch (error) {
              console.error("Failed to save invoice", error);
              Toast.show("Unable to save invoice. Please try again.", "error");
            }
          });

          invoiceCancelEdit.addEventListener("click", () => {
            resetInvoiceForm();
          });

          paymentForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            const data = new FormData(paymentForm);
            const client = String(data.get("client") || "").trim();
            const amount = Number(data.get("amount"));
            const dateValue = String(data.get("date") || "").trim();
            if (!client) {
              Toast.show("Client is required.", "error");
              return;
            }
            if (!Number.isFinite(amount) || amount <= 0) {
              Toast.show("Payment amount must be greater than zero.", "error");
              return;
            }
            if (!DateUtils.fromIso(dateValue)) {
              Toast.show("Provide a valid payment date.", "error");
              return;
            }
            const payload = {
              date: dateValue,
              client,
              amount,
              method: String(data.get("method") || "Card"),
              reference: String(data.get("reference") || "").trim(),
            };
            try {
              if (editingPaymentId) {
                await AppStore.updatePayment(editingPaymentId, payload);
                Toast.show("Payment updated.", "success");
              } else {
                await AppStore.addPayment(payload);
                Toast.show("Payment recorded.", "success");
              }
              resetPaymentForm();
              renderPayments();
              Dashboard.refresh();
              Reports.render();
              requestSync("payment-change");
            } catch (error) {
              console.error("Failed to save payment", error);
              Toast.show("Unable to save payment. Please try again.", "error");
            }
          });

          paymentCancelEdit.addEventListener("click", () => {
            resetPaymentForm();
          });

          document.getElementById("quick-add-payment").addEventListener("click", () => {
            Tabs.show("payments");
            resetPaymentForm();
            if (paymentForm.date) {
              paymentForm.date.value = DateUtils.todayIso();
            }
            document.getElementById("payment-client").focus();
          });

          document.getElementById("generate-invoice").addEventListener("click", () => {
            const invoices = AppStore.getInvoices();
            if (invoices.length === 0) {
              Toast.show("Create an invoice before exporting.", "warning");
              return;
            }
            const settings = AppStore.settings;
            const bookingIndex = new Map(
              AppStore.getAllBookings().map((booking) => [booking.id, booking])
            );
            const doc = [
              `${settings.name} â€¢ Invoice Summary`,
              `Generated: ${new Date().toLocaleString()}`,
              "",
              ...invoices.map((invoice) => {
                const booking = bookingIndex.get(invoice.bookingId);
                const dueDisplay = DateUtils.display(invoice.dueDate);
                return `${invoice.number || "INV"} â€¢ ${booking ? booking.client : "Booking archived"} â€¢ $${Number(
                  invoice.amount || 0
                ).toFixed(2)} â€¢ ${(invoice.status || "draft").toUpperCase()} â€¢ Due ${dueDisplay}`;
              }),
            ].join("\n");
            const blob = new Blob([doc], { type: "text/plain;charset=utf-8" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            const safeName = TextUtils.sanitizeFileSegment(settings.name);
            link.download = `${safeName}_invoice-summary.txt`;
            document.body.appendChild(link);
            link.click();
            setTimeout(() => {
              URL.revokeObjectURL(link.href);
              link.remove();
            }, 0);
            Toast.show("Invoice summary exported.", "success");
          });

          document.querySelectorAll('[data-export]').forEach((button) => {
            button.addEventListener("click", () => {
              const type = button.dataset.export;
              let records = [];
              let schema = [];
              if (type === "bookings") {
                records = AppStore.getAllBookings();
                schema = ["id", "date", "client", "service", "startTime", "endTime", "status"];
              } else if (type === "invoices") {
                records = AppStore.getInvoices();
                schema = ["id", "number", "bookingId", "amount", "status", "dueDate"];
              } else if (type === "payments") {
                records = AppStore.getPayments();
                schema = ["id", "date", "client", "amount", "method", "reference"];
              }
              const header = schema.join(",");
              const rows = records.map((record) =>
                schema.map((key) => TextUtils.escapeCsvCell(record[key])).join(",")
              );
              const csv = [header, ...rows].join("\n");
              const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
              const link = document.createElement("a");
              link.href = URL.createObjectURL(blob);
              const safeName = TextUtils.sanitizeFileSegment(AppStore.settings.name);
              link.download = `${safeName}_${type}_${DateUtils.todayIso().replaceAll("-", "")}.csv`;
              document.body.appendChild(link);
              link.click();
              setTimeout(() => {
                URL.revokeObjectURL(link.href);
                link.remove();
              }, 0);
              Toast.show(`${type.charAt(0).toUpperCase() + type.slice(1)} exported.`, "success");
            });
          });

          const refreshAll = () => {
            refreshInvoiceOptions();
            renderInvoices();
            renderPayments();
          };

          return {
            init() {
              refreshAll();
              resetInvoiceForm();
              resetPaymentForm();
            },
            refreshInvoiceOptions,
            renderInvoices,
            renderPayments,
            refreshAll,
            resetInvoiceForm,
            resetPaymentForm,
          };
        })();

        const Reports = (() => {
          const chartCanvas = document.getElementById("revenue-chart");

          const emptyState = document.getElementById("revenue-chart-empty");
          const highlightsList = document.getElementById("report-highlights");
          const highlightsEmpty = document.getElementById("report-empty");
          const summaryNode = document.getElementById("revenue-chart-summary");
          const ChartLib = globalThis.Chart;

          if (!chartCanvas) {
            throw new Error("Revenue chart canvas element is missing.");
          }
          if (!ChartLib) {
            Toast.show("Unable to load reporting charts. Please check your connection.", "error");
            return {
              render() {
                emptyState.classList.remove("hidden");
                chartCanvas.setAttribute("aria-hidden", "true");
                if (summaryNode) {
                  summaryNode.textContent = "Revenue charts are unavailable because Chart.js failed to load.";
                }
              },
            };
          }

          let chartInstance = null;


          const getAccentColor = () => {
            const accent = getComputedStyle(document.documentElement).getPropertyValue("--brand-accent");
            return accent ? accent.trim() : defaultState.settings.color;
          };

          const hexToRgba = (hex, alpha = 1) => {
            const fallback = `rgba(168, 85, 247, ${alpha})`;
            if (!hex) return fallback;
            let value = hex.trim().replace(/^#/, "");
            if (value.length === 3) {
              value = value
                .split("")
                .map((char) => char + char)
                .join("");
            }
            if (value.length !== 6) return fallback;
            const numeric = Number.parseInt(value, 16);
            if (Number.isNaN(numeric)) return fallback;
            const r = (numeric >> 16) & 255;
            const g = (numeric >> 8) & 255;
            const b = numeric & 255;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
          };


          const updateSummary = (dataset) => {
            if (!summaryNode) return;
            if (dataset.length === 0) {
              summaryNode.textContent = "Revenue trend chart with no data yet.";
              return;
            }
            const total = dataset.reduce((sum, item) => sum + item.total, 0);
            const first = dataset[0];
            const last = dataset[dataset.length - 1];
            const average = total / dataset.length;
            summaryNode.textContent = `Monthly revenue trend from ${first.label} to ${last.label}. Total $${total.toFixed(
              2
            )} across ${dataset.length} month${dataset.length === 1 ? "" : "s"} with an average of $${average.toFixed(
              2
            )} per month.`;
          };

          const renderChart = (dataset) => {
            if (dataset.length === 0) {
              emptyState.classList.remove("hidden");
              chartCanvas.setAttribute("aria-hidden", "true");
              if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
              }
              return;
            }

            emptyState.classList.add("hidden");
            chartCanvas.setAttribute("aria-hidden", "false");

            const labels = dataset.map((item) => item.label);
            const values = dataset.map((item) => Number(item.total || 0));
            const accent = getAccentColor();
            const background = hexToRgba(accent, 0.2);
            const borderHover = hexToRgba(accent, 0.35);
            const maxValue = values.length ? Math.max(...values) : 0;
            const suggestedMax = maxValue > 0 ? maxValue * 1.1 : undefined;

            if (!chartInstance) {
              chartInstance = new ChartLib(chartCanvas, {
                type: "line",
                data: {
                  labels: [],
                  datasets: [
                    {
                      label: "Monthly revenue",
                      data: [],
                      borderWidth: 3,
                      tension: 0.35,
                      fill: true,
                    },
                  ],
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  interaction: { intersect: false, mode: "index" },
                  plugins: {
                    legend: { display: false },
                    tooltip: {
                      backgroundColor: "rgba(15, 23, 42, 0.9)",
                      borderColor: "rgba(148, 163, 184, 0.2)",
                      borderWidth: 1,
                      padding: 12,
                      callbacks: {
                        title(context) {
                          return context?.[0]?.label ?? "";
                        },
                        label(context) {
                          const value = Number(context.parsed.y ?? 0);
                          return `Revenue: $${value.toLocaleString(undefined, {
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 2,
                          })}`;
                        },
                      },
                    },
                  },
                  scales: {
                    x: {
                      ticks: { color: "rgba(148, 163, 184, 0.85)" },
                      grid: { color: "rgba(148, 163, 184, 0.15)" },
                    },
                    y: {
                      beginAtZero: true,
                      ticks: {
                        color: "rgba(148, 163, 184, 0.85)",
                        callback(value) {
                          return `$${Number(value).toLocaleString()}`;
                        },
                      },
                      grid: { color: "rgba(148, 163, 184, 0.12)" },
                    },
                  },
                },
              });
            }

            chartInstance.data.labels = labels;
            const chartDataset = chartInstance.data.datasets[0];
            chartDataset.data = values;
            chartDataset.borderColor = accent;
            chartDataset.backgroundColor = background;
            chartDataset.pointBackgroundColor = accent;
            chartDataset.pointBorderColor = borderHover;
            chartDataset.pointHoverBackgroundColor = accent;
            chartDataset.pointHoverBorderColor = hexToRgba(accent, 0.45);
            chartDataset.pointRadius = 4;
            chartDataset.pointHoverRadius = 6;
            chartDataset.pointHitRadius = 20;

            if (typeof suggestedMax === "number" && Number.isFinite(suggestedMax)) {
              chartInstance.options.scales.y.suggestedMax = suggestedMax;
            } else {
              delete chartInstance.options.scales.y.suggestedMax;
            }
            chartInstance.update();

          };

          const renderHighlights = (dataset) => {
            highlightsList.innerHTML = "";
            if (dataset.length === 0) {
              highlightsEmpty.classList.remove("hidden");
              return;
            }
            highlightsEmpty.classList.add("hidden");
            const total = dataset.reduce((sum, item) => sum + item.total, 0);
            const sorted = [...dataset].sort((a, b) => b.total - a.total);
            const best = sorted[0];
            const worst = sorted[sorted.length - 1];
            const entries = [
              `Total revenue across ${dataset.length} months: $${total.toFixed(2)}`,
              `Average monthly revenue: $${(total / dataset.length).toFixed(2)}`,
              `Best month: ${best.label} with $${best.total.toFixed(2)}`,
              `Lowest month: ${worst.label} with $${worst.total.toFixed(2)}`,
            ];
            entries.forEach((entry) => {
              const li = document.createElement("li");
              li.textContent = entry;
              highlightsList.appendChild(li);
            });
          };

          return {
            render() {
              const payments = AppStore.getPayments();
              const grouped = new Map();
              payments.forEach((payment) => {
                const parsed = DateUtils.fromIso(payment.date);
                if (!parsed) return;
                const key = `${parsed.getFullYear()}-${String(parsed.getMonth() + 1).padStart(2, "0")}`;
                const label = parsed.toLocaleDateString(undefined, { month: "short", year: "numeric" });
                if (!grouped.has(key)) grouped.set(key, { key, label, total: 0 });
                grouped.get(key).total += Number(payment.amount || 0);
              });
              const dataset = Array.from(grouped.values()).sort((a, b) => a.key.localeCompare(b.key));
              renderChart(dataset);
              renderHighlights(dataset);
              updateSummary(dataset);
            },
          };
        })();

        const Settings = (() => {
          const form = document.getElementById("settings-form");
          const preview = {
            name: document.getElementById("brand-preview-name"),
            email: document.getElementById("brand-preview-email"),
            phone: document.getElementById("brand-preview-phone"),
            address: document.getElementById("brand-preview-address"),
          };
          const brandingTitle = document.getElementById("branding-title");

          const requestSync = (reason) => {
            const sync = window.ZantraSync;
            if (sync && typeof sync.trigger === "function") {
              sync.trigger(reason).catch(() => {});
            }
          };

          const applyPreview = (settings) => {
            brandingTitle.textContent = `${settings.name} Console`;
            preview.name.textContent = settings.name;
            preview.email.textContent = settings.email;
            preview.phone.textContent = settings.phone || "â€”";
            preview.address.textContent = settings.address || "â€”";
            Theme.setAccent(settings.color || defaultState.settings.color);
          };

          form.addEventListener("submit", async (event) => {
            event.preventDefault();
            const data = new FormData(form);
            const updates = {
              name: String(data.get("name") || "").trim(),
              email: String(data.get("email") || "").trim(),
              phone: String(data.get("phone") || "").trim(),
              color: data.get("color") || "#3b82f6",
              address: String(data.get("address") || "").trim(),
            };
            if (!updates.name || !updates.email) {
              Toast.show("Name and email are required for branding.", "error");
              return;
            }
            try {
              const updated = await AppStore.updateSettings(updates);
              applyPreview(updated);
              Reports.render();
              Toast.show("Brand settings saved.", "success");
              requestSync("settings-change");
            } catch (error) {
              console.error("Failed to update settings", error);
              Toast.show("Unable to save settings. Please try again.", "error");
            }
          });

          return {
            init() {
              const settings = AppStore.settings;
              form.name.value = settings.name;
              form.email.value = settings.email;
              form.phone.value = settings.phone;
              form.color.value = settings.color;
              form.address.value = settings.address;
              applyPreview(settings);
            },
          };
        })();

        const Dashboard = (() => {
          const summaryUpcoming = document.getElementById("summary-upcoming");
          const summaryOpenInvoices = document.getElementById("summary-open-invoices");
          const summaryMonthPayments = document.getElementById("summary-month-payments");
          const notificationsList = document.getElementById("dashboard-notifications");
          const emptyState = document.getElementById("dashboard-empty-state");

          return {
            refresh() {
              const upcoming = AppStore.getUpcomingBookings();
              const openInvoices = AppStore.getOpenInvoices();
              const now = new Date();
              const paymentsThisMonth = AppStore.getPaymentsForMonth(now.getFullYear(), now.getMonth());
              const totalPayments = paymentsThisMonth.reduce((sum, item) => sum + Number(item.amount || 0), 0);

              summaryUpcoming.textContent = upcoming.length;
              summaryOpenInvoices.textContent = openInvoices.length;
              summaryMonthPayments.textContent = `$${totalPayments.toFixed(2)}`;

              notificationsList.innerHTML = "";
              const notifications = [];

              upcoming.forEach((booking) => {
                notifications.push({
                  tone: "info",
                  text: `${booking.client} â€” ${booking.service} on ${DateUtils.display(booking.date)} at ${booking.startTime}`,
                });
              });

              openInvoices.forEach((invoice) => {
                notifications.push({
                  tone: invoice.status === "overdue" ? "warning" : "info",
                  text: `${invoice.number || "Invoice"} is ${(invoice.status || "pending").toUpperCase()} and due ${DateUtils.display(
                    invoice.dueDate
                  )}`,
                });
              });

              if (notifications.length === 0) {
                emptyState.classList.remove("hidden");
                return;
              }

              emptyState.classList.add("hidden");
              notifications.forEach((notification) => {
                const item = document.createElement("li");
                item.className = "notification-item";
                item.dataset.tone = notification.tone;

                const dot = document.createElement("span");
                dot.className = `notification-dot ${notification.tone === "warning" ? "warning" : "info"}`;

                const text = document.createElement("p");
                text.className = "text-small m-0";
                text.textContent = notification.text;

                item.append(dot, text);
                notificationsList.appendChild(item);
              });
            },
          };
        })();

        const Sync = (() => {
          const statusNode = document.getElementById("sync-status");
          const SYNC_INTERVAL_MS = 2 * 60 * 1000;
          const LAST_SYNC_STORAGE_KEY = "zantra_bookings_last_sync";
          let intervalId = null;
          let isSyncing = false;
          let lastSyncIso = null;

          const getClient = () => globalThis.supabaseClient || null;
          const isOnline = () => navigator.onLine !== false;
          const getAuthApi = () => (typeof window !== "undefined" ? window.ZantraAuth : null);
          const getUserId = () => {
            const auth = getAuthApi();
            return auth && typeof auth.getUserId === "function" ? auth.getUserId() : null;
          };
          const isAuthenticated = () => {
            const auth = getAuthApi();
            return auth && typeof auth.isAuthenticated === "function" ? auth.isAuthenticated() : false;
          };
          const canSync = () => Boolean(getClient()) && isAuthenticated() && isOnline();

          const loadLastSync = () => {
            if (lastSyncIso) return lastSyncIso;
            try {
              const stored = localStorage.getItem(LAST_SYNC_STORAGE_KEY);
              if (stored) {
                lastSyncIso = stored;
              }
            } catch (error) {
              console.warn("Failed to load last sync time", error);
            }
            return lastSyncIso;
          };

          const saveLastSync = (iso) => {
            lastSyncIso = iso;
            try {
              if (iso) {
                localStorage.setItem(LAST_SYNC_STORAGE_KEY, iso);
              } else {
                localStorage.removeItem(LAST_SYNC_STORAGE_KEY);
              }
            } catch (error) {
              console.warn("Failed to persist last sync time", error);
            }
          };

          const clearLastSync = () => {
            saveLastSync(null);
          };

          const formatTimestamp = (iso) => {
            if (!iso) return "Awaiting sync";
            const date = new Date(iso);
            if (Number.isNaN(date.getTime())) return "Awaiting sync";
            return `Synced ${date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`;
          };

          const updateStatus = (state, message) => {
            if (!statusNode) return;
            statusNode.dataset.state = state;
            statusNode.textContent = message;
          };

          const convertForRemote = (table, record, userId) => {
            const { dirty, userId: localUserId, updatedAt, ...rest } = record;
            return Object.assign({}, rest, {
              updated_at: updatedAt || new Date().toISOString(),
              user_id: localUserId || userId,
            });
          };

          const pushLocalChanges = async () => {
            const userId = getUserId();
            if (!userId) return;
            const dirty = await AppStore.getDirtyRecords();
            const tables = ["bookings", "invoices", "payments", "settings"];
            for (const table of tables) {
              const records = dirty[table];
              if (!Array.isArray(records) || records.length === 0) continue;
              const payload = records.map((record) => convertForRemote(table, record, userId));
              const client = getClient();
              if (!client) return;
              const { data, error } = await client
                .from(table)
                .upsert(payload, { onConflict: "id" })
                .select();
              if (error) throw error;
              const response = Array.isArray(data) && data.length ? data : payload;
              await AppStore.markRecordsClean(
                table,
                response.map((item) => ({
                  ...item,
                  updated_at: item.updated_at || item.updatedAt || new Date().toISOString(),
                  user_id: item.user_id || userId,
                }))
              );
            }
          };

          const pullRemoteChanges = async () => {
            const client = getClient();
            const userId = getUserId();
            if (!client || !userId) return null;
            const since = loadLastSync();
            let newest = since ? Date.parse(since) : 0;
            const tables = ["bookings", "invoices", "payments", "settings"];
            for (const table of tables) {
              let query = client.from(table).select("*").eq("user_id", userId);
              if (since) {
                query = query.gt("updated_at", since);
              }
              const { data, error } = await query.order("updated_at", { ascending: true });
              if (error) throw error;
              if (Array.isArray(data) && data.length) {
                await AppStore.mergeRemoteRecords(table, data);
                const latest = data[data.length - 1].updated_at;
                if (latest) {
                  const parsed = Date.parse(latest);
                  if (!Number.isNaN(parsed)) {
                    newest = Math.max(newest, parsed);
                  }
                }
              }
            }
            return newest ? new Date(newest).toISOString() : since;
          };

          const synchronize = async (reason = "manual") => {
            if (!canSync()) {
              const message = !isOnline()
                ? "Offline"
                : isAuthenticated()
                ? "Awaiting sync"
                : "Sign in to sync";
              updateStatus("idle", message);
              return;
            }
            if (isSyncing) return;
            isSyncing = true;
            updateStatus("syncing", "Syncingâ€¦");
            try {
              await AppStore.ready();
              await pushLocalChanges();
              const remoteIso = await pullRemoteChanges();
              const finalIso = remoteIso || new Date().toISOString();
              saveLastSync(finalIso);
              updateStatus("synced", formatTimestamp(finalIso));
              if (typeof Calendar?.refresh === "function") {
                Calendar.refresh();
              }
              if (typeof Payments?.refreshAll === "function") {
                Payments.refreshAll();
              }
              if (typeof Dashboard?.refresh === "function") {
                Dashboard.refresh();
              }
              if (typeof Reports?.render === "function") {
                Reports.render();
              }
            } catch (error) {
              console.error("Sync failed", error);
              updateStatus("error", "Sync failed");
              Toast.show("Sync failed. We'll retry shortly.", "warning");
              throw error;
            } finally {
              isSyncing = false;
            }
          };

          const startInterval = () => {
            if (intervalId) window.clearInterval(intervalId);
            intervalId = window.setInterval(() => {
              synchronize("interval").catch(() => {});
            }, SYNC_INTERVAL_MS);
          };

          window.addEventListener("online", () => {
            if (canSync()) {
              synchronize("online").catch(() => {});
            } else if (statusNode) {
              updateStatus("idle", "Offline");
            }
          });

          const init = () => {
            const saved = loadLastSync();
            if (statusNode) {
              const state = isOnline() ? "idle" : "idle";
              const message = isOnline() ? formatTimestamp(saved) : "Offline";
              updateStatus(state, message);
            }
          };

          return Object.freeze({
            init,
            trigger: (reason) => synchronize(reason),
            handleLogin() {
              loadLastSync();
              startInterval();
              synchronize("login").catch(() => {});
            },
            handleLogout() {
              if (intervalId) {
                window.clearInterval(intervalId);
                intervalId = null;
              }
              clearLastSync();
              if (statusNode) {
                updateStatus("idle", "Signed out");
              }
            },
          });
        })();

        window.ZantraSync = Sync;


        const Auth = (() => {
          const SUBSCRIPTION_INACTIVE_MESSAGE = "Your subscription is inactive. Please contact support.";
          const client = globalThis.supabaseClient || null;
          const appShell = document.getElementById("app");
          const authScreen = document.getElementById("auth-container");
          const loginForm = document.getElementById("login-form");
          const emailInput = document.getElementById("login-email");
          const passwordInput = document.getElementById("login-password");
          const submitButton = document.getElementById("login-submit");
          const errorNode = document.getElementById("login-error");
          const logoutButton = document.getElementById("logout-button");
          const subscriptionScreen = document.getElementById("subscription-blocked");
          const subscriptionMessageNode = document.getElementById(
            "subscription-blocked-message",
          );
          const subscriptionReturnButton = document.getElementById(
            "subscription-blocked-return",
          );

          let activeUserId = null;
          let bootstrapped = false;
          let pendingLoginToast = false;
          window.ZantraAuthUserId = null;
          let subscriptionBlocked = false;
          let subscriptionBlockedMessage = SUBSCRIPTION_INACTIVE_MESSAGE;
          let lastSubscriptionError = "";

          const setError = (message) => {
            if (!errorNode) return;
            if (message) {
              errorNode.textContent = message;
              errorNode.classList.remove("hidden");
            } else {
              errorNode.textContent = "";
              errorNode.classList.add("hidden");
            }
          };

          const setLoading = (isLoading) => {
            if (submitButton) {
              submitButton.disabled = isLoading;
              submitButton.textContent = isLoading ? "Signing in..." : "Sign in";
            }
            if (emailInput) emailInput.disabled = isLoading;
            if (passwordInput) passwordInput.disabled = isLoading;
          };

          const focusEmail = () => {
            if (!emailInput) return;
            requestAnimationFrame(() => {
              emailInput.focus();
            });
          };

          const hideSubscriptionBlocked = () => {
            if (subscriptionScreen) subscriptionScreen.classList.add("hidden");
          };

          const showSubscriptionBlocked = (message) => {
            if (subscriptionMessageNode && message) {
              subscriptionMessageNode.textContent = message;
            }
            if (authScreen) authScreen.classList.add("hidden");
            if (appShell) appShell.classList.add("hidden");
            if (logoutButton) logoutButton.classList.add("hidden");
            if (subscriptionScreen) subscriptionScreen.classList.remove("hidden");
            setError("");
            setLoading(false);
          };

          const showScreen = () => {
            hideSubscriptionBlocked();
            if (authScreen) authScreen.classList.remove("hidden");
            if (appShell) appShell.classList.add("hidden");
            if (logoutButton) logoutButton.classList.add("hidden");
            setLoading(false);
            if (passwordInput) passwordInput.value = "";
            focusEmail();
          };

          const hideScreen = () => {
            hideSubscriptionBlocked();
            if (authScreen) authScreen.classList.add("hidden");
            if (appShell) appShell.classList.remove("hidden");
            if (logoutButton) logoutButton.classList.remove("hidden");
            if (loginForm) loginForm.reset();
            setError("");
            setLoading(false);
          };

          const verifySubscription = async (userId) => {
            const defaultError = "Unable to verify subscription. Please try again later.";
            if (!client) {
              return { allowed: false, code: "error", message: defaultError };
            }
            try {
              const { data, error } = await client
                .from("profiles")
                .select("active_subscription")
                .eq("id", userId)
                .maybeSingle();
              if (error) {
                console.error("Subscription lookup failed", error);
                return { allowed: false, code: "error", message: defaultError };
              }
              if (!data) {
                return {
                  allowed: false,
                  code: "inactive",
                  message: SUBSCRIPTION_INACTIVE_MESSAGE,
                };
              }
              if (data.active_subscription) {
                return { allowed: true };
              }
              return {
                allowed: false,
                code: "inactive",
                message: SUBSCRIPTION_INACTIVE_MESSAGE,
              };
            } catch (error) {
              console.error("Subscription enforcement failed", error);
              return { allowed: false, code: "error", message: defaultError };
            }
          };

          const bootstrapApp = async () => {
            await AppStore.ready();

            if (!bootstrapped) {
              Tabs.show("dashboard");
              Calendar.init();
              Payments.init();
              Settings.init();
              Dashboard.refresh();
              Reports.render();
              bootstrapped = true;
              return;
            }
            Tabs.show("dashboard");
            if (typeof Calendar.resetFormState === "function") {
              Calendar.resetFormState();
            }
            if (typeof Payments.refreshAll === "function") {
              Payments.refreshAll();
            }
            Dashboard.refresh();
            Reports.render();
          };

          const handleSessionChange = async (session, eventType = "STATE_CHANGE", options = {}) => {
            const {
              subscriptionResult: providedSubscriptionResult,
              suppressSignOutToast = false,
            } = options;

            const wasAuthenticated = Boolean(activeUserId);
            if (session && session.user) {
              activeUserId = session.user.id;
              window.ZantraAuthUserId = activeUserId;
              const subscriptionResult =
                providedSubscriptionResult || (await verifySubscription(activeUserId));
              if (!subscriptionResult.allowed) {
                pendingLoginToast = false;
                subscriptionBlocked = subscriptionResult.code === "inactive";
                subscriptionBlockedMessage =
                  subscriptionResult.message || SUBSCRIPTION_INACTIVE_MESSAGE;

                if (subscriptionBlocked) {
                  showSubscriptionBlocked(subscriptionBlockedMessage);
                  if (typeof window !== "undefined") {
                    window.alert(subscriptionBlockedMessage);
                  }
                  lastSubscriptionError = "";
                } else {
                  setError(subscriptionBlockedMessage);
                  showScreen();
                  lastSubscriptionError = subscriptionBlockedMessage;
                }

                try {
                  await client.auth.signOut();
                } catch (error) {
                  console.error("Failed to sign out after subscription enforcement", error);
                }
                activeUserId = null;
                window.ZantraAuthUserId = null;
                return;
              }

              subscriptionBlocked = false;
              subscriptionBlockedMessage = SUBSCRIPTION_INACTIVE_MESSAGE;
              hideSubscriptionBlocked();
              hideScreen();
              await bootstrapApp();
              if (typeof Sync?.handleLogin === "function") {
                Sync.handleLogin();
              }

              if (pendingLoginToast || (!wasAuthenticated && eventType === "INITIAL_SESSION")) {
                Toast.show("Signed in successfully.", "success");
              }
              pendingLoginToast = false;
              lastSubscriptionError = "";
            } else {
              activeUserId = null;
              window.ZantraAuthUserId = null;
              setError("");
              if (!subscriptionBlocked && lastSubscriptionError) {
                setError(lastSubscriptionError);
              }
              if (subscriptionBlocked) {
                showSubscriptionBlocked(subscriptionBlockedMessage);
              } else {
                showScreen();
              }
              if (
                !subscriptionBlocked &&
                (wasAuthenticated || eventType === "SIGNED_OUT") &&
                !suppressSignOutToast
              ) {
                Toast.show("Signed out.", "info");
              }
              if (typeof Sync?.handleLogout === "function") {
                Sync.handleLogout();
              }

              pendingLoginToast = false;
            }
          };

          const bindEvents = () => {
            if (loginForm) {
              loginForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                if (!client) {
                  setError("Authentication is unavailable. Please try again later.");
                  return;
                }
                const formData = new FormData(loginForm);
                const email = String(formData.get("email") || "").trim();
                const password = String(formData.get("password") || "");
                if (!email || !password) {
                  setError("Email and password are required.");
                  return;
                }
                setError("");
                setLoading(true);
                pendingLoginToast = true;
                try {
                  const { data, error } = await client.auth.signInWithPassword({ email, password });
                  if (error || !data?.session) {
                    pendingLoginToast = false;
                    setError(error?.message || "Unable to sign in. Please check your credentials.");
                    return;
                  }

                  const subscriptionResult = await verifySubscription(data.session.user.id);
                  await handleSessionChange(data.session, "MANUAL_SIGN_IN", { subscriptionResult });
                  if (!subscriptionResult.allowed) {
                    return;
                  }

                } catch (error) {
                  pendingLoginToast = false;
                  console.error("Failed to sign in", error);
                  setError("Unable to sign in. Please try again.");
                } finally {
                  setLoading(false);
                }
              });
            }

            if (logoutButton) {
              logoutButton.addEventListener("click", async () => {
                if (!client) {
                  await handleSessionChange(null, "MANUAL_SIGN_OUT");
                  return;
                }
                logoutButton.disabled = true;
                try {
                  const { error } = await client.auth.signOut();
                  if (error) {
                    Toast.show("Could not sign out. Please try again.", "error");
                  }
                } catch (error) {
                  console.error("Failed to sign out", error);
                  Toast.show("Could not sign out. Please try again.", "error");
                } finally {
                  await handleSessionChange(null, "MANUAL_SIGN_OUT", { suppressSignOutToast: true });
                  logoutButton.disabled = false;
                }
              });
            }

            if (subscriptionReturnButton) {
              subscriptionReturnButton.addEventListener("click", () => {
                subscriptionBlocked = false;
                subscriptionBlockedMessage = SUBSCRIPTION_INACTIVE_MESSAGE;
                lastSubscriptionError = "";
                hideSubscriptionBlocked();
                showScreen();
              });
            }
          };

          const init = async () => {
            if (!appShell) {
              console.error("Application shell is missing; cannot initialize auth.");
              return;
            }

            hideSubscriptionBlocked();

            if (!client) {
              showScreen();
              setError("Authentication is unavailable. Please try again later.");
              Toast.show("Authentication is unavailable. Please try again later.", "error");
              return;
            }

            bindEvents();

            try {
              const { data, error } = await client.auth.getSession();
              if (error) {
                console.error("Failed to fetch session", error);
                setError("Unable to verify session. Please sign in.");
                showScreen();
              } else if (data?.session?.user) {
                await handleSessionChange(data.session, "INITIAL_SESSION");

              } else {
                showScreen();
              }
            } catch (error) {
              console.error("Session lookup failed", error);
              setError("Unable to verify session. Please sign in.");
              showScreen();
            }

            const { data: listener } = client.auth.onAuthStateChange(async (event, session) => {
              await handleSessionChange(session, event);

            });

            if (listener && typeof listener.subscription?.unsubscribe === "function") {
              window.addEventListener("beforeunload", () => {
                listener.subscription.unsubscribe();
              });
            }
          };

          const api = {
            init,
            getUserId: () => activeUserId,
            isAuthenticated: () => Boolean(activeUserId),
          };

          window.ZantraAuth = api;

          return api;
        })();

        document.addEventListener("DOMContentLoaded", () => {
          if (typeof Sync?.init === "function") {
            Sync.init();
          }

          Auth.init();
        });
      })();
    </script>
  </body>
</html>
